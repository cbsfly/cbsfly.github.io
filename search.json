[{"title":"摆脱第三方库系列（三）- 自己写顶部滚动标签栏","url":"/2021/03/05/2016-04-30-segmentview/","content":"\n\n# 前言\n\n*好久没写博客了，最近自己参考了一些源码写了一个标签页，并把他传到了CocoaPods上。大家可以集成到项目中进行使用，也可以看看源码自己写一个更好的，也希望如果有什么意见可以告诉我，我会进行完善。*\n\n# 成果\n\n自己写了两种形式的Demo，一种类似网易云音乐的固定的标签栏，一种是类似爱奇艺、今日头条的可滚动的标签栏。一开始只是草草的写，后来经过师傅提醒考虑了下优化，只有移动到那个页面才会对ViewController进行加载，这样即使是很复杂的页面很多网络请求数据加载应该也不会有卡顿的现象。\n\n![wait](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/iOS/segment1.gif)\n\n![wait](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/iOS/segment2.gif)\n\n如果有想加入项目中使用的同学可以利用CocoaPods，具体使用我放在[github](https://github.com/cbsfly/CBSSegmentView)上了，欢迎使用。也可以把github上的zip直接下载下来看使用方法。接下来简单介绍下实现原理。\n\n# 实现原理\n\n简单的说，顶部的标签栏是UIScrollView，底下也是一个UIScrollView，将多个`ViewController.view`初始化加入到下面ScrollView中的合适位置，并且与顶部的标签栏相关联，并且给上面的标签栏增加点击事件控制下部分的ScrollView可以移动到合适的位置就行了！\n\n# 部分源码解析\n\n感觉其实没什么难点，比较需要动脑筋的实现应该就是顶部标签栏随下面ScrollView的滑动，包括字体颜色，下划线移动。我就对这一部分进行介绍，对其他地方感兴趣的同学可以自己把源码下载下来看看。\n\n这里先上代码，先上顶部标签栏的初始化方法。这一部分比较繁琐，肯定可以简化代码，时间有点紧就没做了。\n\n\t- (void)addScrollHeader:(NSArray *)titleArray\n\t{\n\t    self.headerView.frame = CGRectMake(0, 0, self.width, self.buttonHeight);\n\t    self.headerView.contentSize = CGSizeMake(self.buttonWidth*titleArray.count, self.buttonHeight);\n\t    [self addSubview:self.headerView];\n    \n\t    for (NSInteger index = 0; index < titleArray.count; index++) {\n\t        _titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(self.buttonWidth*index, 0, self.buttonWidth, self.buttonHeight)];\n\t        _titleLabel.textColor = [UIColor blackColor];\n\t        _titleLabel.text = titleArray[index];\n\t        _titleLabel.textAlignment = NSTextAlignmentCenter;\n\t        _titleLabel.adjustsFontSizeToFitWidth = YES;\n\t        [self.headerView addSubview:_titleLabel];\n        \n\t        _segmentBtn = [[UIButton alloc] initWithFrame:CGRectMake(self.buttonWidth*index, 0, self.buttonWidth, self.buttonHeight)];\n\t        _segmentBtn.tag = index;\n\t        [_segmentBtn setBackgroundColor:[UIColor clearColor]];\n\t        [_segmentBtn addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchUpInside];\n\t        [self.headerView addSubview:_segmentBtn];\n\t    }\n    \n    \n\t    self.headerSelectedSuperView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, self.buttonWidth, self.buttonHeight)];\n\t    [self.headerView addSubview:self.headerSelectedSuperView];\n    \n\t    self.headerSelectedView.frame =CGRectMake(0, 0, self.buttonWidth, self.buttonHeight);\n\t    self.headerSelectedView.contentSize = CGSizeMake(self.buttonWidth*titleArray.count, self.buttonHeight);\n\t    [self.headerSelectedSuperView addSubview:self.headerSelectedView];\n\n\t    for (NSInteger index = 0; index < titleArray.count; index++) {\n\t        _titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(self.buttonWidth*index, 0, self.buttonWidth, self.buttonHeight)];\n\t        _titleLabel.textColor = [UIColor blueColor];\n\t        _titleLabel.text = titleArray[index];\n\t        _titleLabel.textAlignment = NSTextAlignmentCenter;\n\t        _titleLabel.adjustsFontSizeToFitWidth = YES;\n\t        [self.headerSelectedView addSubview:_titleLabel];\n        \n\t    }\n\n\t    UIImageView *bottomLine = [[UIImageView alloc] initWithFrame:CGRectMake(0, self.headerSelectedView.contentSize.height - self.lineHeight, self.headerSelectedView.contentSize.width, self.lineHeight)];\n\t    bottomLine.backgroundColor = [UIColor blueColor];\n\t    [self.headerSelectedView addSubview:bottomLine];\n\t}\n\t\n这里的实现主要分成三个步骤，一开始在顶部加上一个`self.headerView`，这是一个UIScrollView，他是标签栏视图的最底层，所以需要最先add上去。在`self.headerView`我们会加上若干个UILabel，这几个UILabel就是没选中时的标签样子，就是上文gif中黑色的标签。然后再加上若干个透明的Button方便添加点击事件，当然也可以用手势这里随意。\n\n第二步就是加一个UIView的“父视图”`self.headerSelectedSuperView`,这个父视图的作用稍后说。\n\n第三步就是再加上一个UIScrollView`self.headerSelectedView`,这是当前选中标签应该展现的外观的ScrollView，我们在这个ScrollView里加入若干个UILabel，不同的是颜色要设置成选中标签后的颜色，这里我设置的是蓝色。为了美观，还加了一个蓝色的下划线。第三步有个关健就是将`        _headerSelectedView.clipsToBounds = YES;`这个代码我在headerSelectedView的get方法里面写了。这个属性是说子视图如果比父视图大，则将超出的部分去掉，默认是NO的。不是很理解的最好取谷歌下，这个属性是实现上图效果的关健。\n\n然后看UIScrollView的代理方法。\n\n\t- (void)scrollViewDidScroll:(UIScrollView *)scrollView\n\t{\n\t    if (scrollView == _backView) {\n\t        self.headerSelectedSuperView.frame = CGRectMake(scrollView.contentOffset.x * (self.buttonWidth/self.width), self.headerSelectedSuperView.frame.origin.y, self.headerSelectedSuperView.frame.size.width, self.headerSelectedSuperView.frame.size.height);\n\t        self.headerSelectedView.contentOffset = CGPointMake(scrollView.contentOffset.x * (self.buttonWidth/self.width), 0);\n\t    }\n\t}\n\t\nbackView就是下面ViewController存放的ScrollView，当backView滚动时，我们需要改变标签栏headerSelectedSuperView的frame和headerSelectedView的contentOffset，这样的结果就是headerSelectedSuperView能移动到合适的位置，并且展示出headerSelectedSuperView子视图也就是headerSelectedView合适的部分。这样就能有gif中标签栏的那种滚动效果了。这里就和`        _headerSelectedView.clipsToBounds = YES;`息息相关了。代码很简单。\n\n至于其他部分我就不一一解析了，还是推荐大家看看源码，也希望有什么意见可以告诉我，互相提高互相进步。","categories":["iOS"]},{"title":"用AFNetworking3.0封装网络请求","url":"/2021/03/05/2016-01-15-network/","content":"# 前言\n\n由于之前一直是用别人封装好的网络请求，一来版本太旧，二来觉得太臃肿很多功能代码不知道是干嘛的，所以想尝试自己封装一个网络请求，可能比较简单比较入门，很多问题肯定考虑不周，而且网上关于AFNetworking3.0库的教程也不多，所以大家当成3.0的小教程就好。\n\n# 配置AFNetworking环境\n\n[AFNetworking](https://github.com/AFNetworking/AFNetworking)更新了3.0，之前的工程一直用的2.63。这两个版本变化还是比较大的，以前的AFNetworking是NSURLConnection + NSOperation，但是**3.0版本移除了对NSURLConnectionOperation的支持**，这意味着之前版本的“主力军”被移除了，所以若是原封不动的用之前工程网络请求部分的代码一般都会报错，所以大家都要尝试用新版的AFNetworking来更新自己的网络请求了。取消了NSURLConnectionOperation，AFNetworking是用iOS7中新的网络接口NSURLSessionOperation来代替的。NSURLSessionOperation在程序进入后台后会比NSURLConnectionOperation更加灵活，更先进。\n\n为了使用AFNetworking3.0，还有一个比较坑爹的是你必须使用Xcode7以上的版本。因为AFNetworking3.0 使用了`nullable`新特性，而低版本的Xcode并不识别，所以用低版本的Xcode运行3.0会报错。更坑爹的是要用Xcode7还要更新你OS X到EI Capitan版本，光更新这两个我就花了一天的时间（其实笔者下载了两次Xcode7才发现要先更新操作系统才行）。更新操作系统踩坑点[这里](http://www.jianshu.com/p/15deb543bb52)。\n\n有了Xcode7，就可以用cococapods下载配置最新的AFNetworking了。\n\n\tplatform :ios, '8.0'\n\tpod 'AFNetworking', '~> 3.0'\n\t\n坑爹的事还有，在iOS 9中 苹果将原http协议改成了https协议 使用 TLS1.2 SSL加密请求数据，所以我们不能直接请求http协议下的数据了。\n\n解决办法也很简单，用编辑器打开工程文件下的Info.plist文件添加下面的代码就可以了\n\n\t<key>NSAppTransportSecurity</key>  \n    \t<dict>  \n          <key>NSAllowsArbitraryLoads</key><true/>  \n    \t</dict>  \n    \t\nstackoverflow的回答点[这里](http://stackoverflow.com/questions/31254725/transport-security-has-blocked-a-cleartext-http)。\n\n这样一来我们就配置好环境了。\n\n# 使用AFNetworking\n很多人对AFNetworking都不陌生，这一段可能有点老生常谈的感觉。\n\n用AFNetworking第一步都是一样的，即创建一个manager。关于self-manager的扩展可以看[这篇文章](http://blog.sunnyxx.com/2015/12/19/self-manager-pattern-in-ios/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)学习一下。\n\n在AFNetworking中创建manager的方法是这样的\n\n    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];\n\n在AppDelegate中你需要开启你的网络监听器，这样AFStringFromNetworkReachabilityStatus属性就有了值显示你的网络状态。\n\n    [[AFNetworkReachabilityManager sharedManager] startMonitoring];\n\n如果你需要上传或者下载数据，那么还需要创建一个NSURLSessionConfiguration类，本文只讲述普通的请求数据，所以先不涉及NSURLSessionConfiguration。\n\n请求数据大部分情况下就是像服务器发送GET或者POST请求，然后服务器会返回你一串JSON格式的数据，你需要解析这段JSON数据然后呈现在你的UI上。\n\n>GET - 从指定的资源请求数据。\n>\n>POST - 向指定的资源提交要被处理的数据\n\t\nAFNetworking请求数据的代码也很简单。\n\n\t[manager GET:@\"http://httpbin.org/get\" parameters:nil progress:nil success:^(NSURLSessionTask *task, id responseObject) {\n        NSLog(@\"JSON: %@\", responseObject);\n    } failure:^(NSURLSessionTask *operation, NSError *error) {\n        NSLog(@\"Error: %@\", error);\n    }];\n    \n这段代码非常易懂，这也是AFNetworking的强大之处。`parameters:`后面跟着的是你需要给后台传送的参数。而`id responseObject`是后台返给你的数据。我输出了一下`[responseObject class]`发现responseObject是一个NSDictionary，那么以后在字典中用的方法也适用于responseObject，后面的代码中我也做了修改。\n\n这样我们就成功请求到了数据。接下来要做的就是封装了。\n\n# 网络请求的封装\n记得学习软件工程的时候我们老师给我们反复强调了代码复用的重要性，我当时也深受启发。而网络请求在我们的应用开发中我觉得是最常用的需要代码复用的部分，因为他使用次数多，且代码都差不多，不受别的模块代码干扰，即低耦合,高内聚。\n\n上文提到了我们进行网络请求要先创建一个manager，就是说每次请求我们都需要创建manager。那么我们先对这一步进行封装。\n\n先创建一个新的继承于AFHTTPSessionManager的类，我这里就叫cbsNetWork了。在我的封装中，一开始我是先创建一个类方法。\n\n\t+ (instancetype)sharedManager {\n    static cbsNetWork *manager = nil;\n    static dispatch_once_t pred;\n    dispatch_once(&pred, ^{\n        manager = [[self alloc] initWithBaseURL:[NSURL URLWithString:@\"http://httpbin.org/\"]];\n    });\n    return manager;\n\t}\n\n这是每次执行网络请求库的时候都要执行的方法。在这个方法中，其实就是初始化了一个manager，但与一般的创建不同，这里用到了`dispatch_once`也就是iOS ARC中创建单例模式的方法。为何这里要用到单例模式？因为这个manager应该是系统中唯一的实例。而`dispatch_once`中的方法不管多少次调用都只会运行一次。更多的关于单例模式点[这个网站](http://www.jianshu.com/p/7486ebfcd93b)吧。\n\n接下来就是重写父类的初始化方法`initWithBaseURL`。在父类(也就是AFNetworking)中`initWithBaseURL`只是拼接了基URL和后来的路径，并且规定了默认的请求序列和响应序列。而在我们的实际工程中肯定需要更多的属性设置，例如延时要求，缓存要求等。这里的属性设置具体原因不用细究，只要知道这个方法的作用就好。\n\n\t-(instancetype)initWithBaseURL:(NSURL *)url\n\t{\n    self = [super initWithBaseURL:url];\n    if (self) {\n        // 请求超时设定\n        self.requestSerializer.timeoutInterval = 5;\n        self.requestSerializer.cachePolicy = NSURLRequestReloadIgnoringLocalCacheData;\n        [self.requestSerializer setValue:@\"application/json\" forHTTPHeaderField:@\"Accept\"];\n        [self.requestSerializer setValue:url.absoluteString forHTTPHeaderField:@\"Referer\"];\n        \n        self.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@\"application/json\", @\"text/plain\", @\"text/javascript\", @\"text/json\", @\"text/html\", nil];\n        \n        self.securityPolicy.allowInvalidCertificates = YES;\n    }\n    return self;\n\t}\n\n然后就是封装AFNetworking的部分了。这里我只是封装了一个请求数据的方法，比较简单，当然不能下载和上传，以后我会完善。\n\n首先我们要在文件头定义两个block，在请求中我们需要用block回调数据来使用，因为AFNetworking请求数据方法中success块是没有返回值的，所以我们需要自己声明块来回调请求到的json数据再进行解析。\n\n块定义如下\n\n\t//请求成功回调block\n\ttypedef void (^requestSuccessBlock)(NSDictionary *dic);\n\n\t//请求失败回调block\n\ttypedef void (^requestFailureBlock)(NSError *error);\n\t\n为了分辨方法，我也定了也一个HTTP方法类来封装方法。\n\n\t//请求方法define\n\ttypedef enum {\n    GET,\n    POST,\n    PUT,\n    DELETE,\n    HEAD\n\t} HTTPMethod;\n\t\n接下来就是方法封装了\n\n\t- (void)requestWithMethod:(HTTPMethod)method\n                 WithPath:(NSString *)path\n               WithParams:(NSDictionary*)params\n         WithSuccessBlock:(requestSuccessBlock)success\n          WithFailurBlock:(requestFailureBlock)failure\n\t{\n    switch (method) {\n        case GET:{\n       \t     [self GET:path parameters:params progress:nil success:^(NSURLSessionTask *task, NSDictionary * responseObject) {\n         \t       NSLog(@\"JSON: %@\", responseObject);\n         \t       success(responseObject);\n       \t     } failure:^(NSURLSessionTask *operation, NSError *error) {\n         \t       NSLog(@\"Error: %@\", error);\n         \t       failure(error);\n        \t    }];\n        \t    break;\n     \t   }\n        case POST:{\n           \t [self POST:path parameters:params progress:nil success:^(NSURLSessionTask *task, NSDictionary * responseObject) {\n              \t  NSLog(@\"JSON: %@\", responseObject);\n         \t       success(responseObject);\n        \t    } failure:^(NSURLSessionTask *operation, NSError *error) {\n            \t    NSLog(@\"Error: %@\", error);\n            \t    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@\"提示\" message:error.localizedDescription delegate:nil cancelButtonTitle:@\"确定\" otherButtonTitles:nil, nil];\n             \t   [alert show];\n            \t    failure(error);\n            \t}];\n            \tbreak;\n        \t}\n        default:\n            break;\n    \t}    \n\t}\n\t\n我只是简单的封装了GET和POST两个方法，成功会讲请求到的json数据存储到一个字典responseObject中，然后通过回调方法在页面中使用，失败的话则回调了`NSError *error`。\n\n在ViewController中，我们即可用一个方法完成网络请求。\n\n\t[[cbsNetWork sharedManager] requestWithMethod:GET WithPath:@\"get\" WithParams:nil WithSuccessBlock:^(NSDictionary *dic) {\n        Model *model = [MTLJSONAdapter modelOfClass:[Model class] fromJSONDictionary:dic error:nil];\n        NSLog(@\"%@\", model.origin);\n    } WithFailurBlock:^(NSError *error) {\n        \n    }];\n    \n*PS：我的model是用Mantle解析的，所以想复制代码的同学自己用自己的办法写model吧，这不是重点。*\n\n这样简单的网络请求就封装好了，当然还可以更加完善可以再加一层专门写model解析数据这样你的ViewController代码会更简洁。\n\n这篇文章写的代码我会传到我的github上，有需要的可以[点开来](https://github.com/cbsfly/cbsNetWork)下载看。\n\n学艺不精，有错误的地方还请指出，我将万分感谢。","categories":["iOS"]},{"title":"Git问题Everything up-to-date解决","url":"/2021/03/05/2016-01-20-git-date/","content":"\n今天push代码的时候遇到了一个小问题，提示『Everything up-to-date』\n，导致不能push代码，说这里解决了记下小记。\n\n# 提交代码遇到『Everything up-to-date』\n\n上网查了下，发现中文大多答非所问，少数能解决的并没有阐述原理，所以我写这篇文章记录下。\n\n这里先上[stackoverflow](http://stackoverflow.com/questions/2936652/git-push-wont-do-anything-everything-up-to-date)的回答，基础好的可以看这个。\n\n接下来说我自己的理解，出现这个问题的原因是git提交改动到缓存，要push的时候不会将本地所有的分支都push掉，所以出现这个问题。我们应该告诉git提交哪个分支。\n\n这里有种特殊的情况是如果你是fork别人的仓库再clone到本地的话，即使git上只有一个主分支，他还是可能出现这个错误。那么我们就需要新建分支提交改动然后合并分支。\n\n接下来先创建一个新分支提交改动\n\n\t$ git branch newbranch\n\t\n然后输入这条命令检查是否创建成功\n\n\t$ git branch\n\t\n这时终端输出\n\n\t  newbranch\n\t* master\n\t\n这样就创建成功了，前面的*代表的是当前你所在的工作分支。我们接下来就要切换工作分支。\n\n\t$ git checkout newbranch\n\t\n这样就切换完了，可以`$ git branch`确认下。然后你要将你的改动提交到新的分支上。\n\n\t$ git add .\n\t$ git commit -a\n\t\n此时可以`$ git status`检查下提交情况。如果提交成功，我们接下来就要回主分支了，代码和之前一样。\n\n\t$ git checkout master\n\t\n然后我们要将新分支提交的改动合并到主分支上\n\n\t$ git merge newbranch\n\t\n合并分支可能产生冲突这是正常的，虽然我们这是新建的分支不会产生冲突，但还是在这里记录下。下面的代码可以查看产生冲突的文件，然后做对应的修改再提交一次就可以了。\n\n\t$ git diff\n\t\n我们的问题就解决了，接下来就可以push代码了。\n\n\t$ git push -u origin master\n\t\n新建分支的朋友别忘了删除这个分支\n\n\t$ git branch -D newbranch\n\t\n如果想保留分支只是想删除已经合并的部分只要把大写的D改成小写的d就行了。\n\n# 参考资料\n\n[分支与合并@基础](http://gitbook.liuhui998.com/3_3.html)","categories":["Git"]},{"title":"利用RAC一句话实现上拉刷新下拉刷新","url":"/2021/03/05/2016-01-21-rac-refresh/","content":"\n最近在研究上拉刷新下拉刷新，有点小心得和大家分享下。\n\n首先我是先在网上搜博客看，发现要不就是用原生UIRefreshControl要不就是第三方库的教程，这都不是我想要的（好的开源库推荐[MJRefresh](https://github.com/CoderMJLee/MJRefresh)）。\n\n于是我开始看大神们的源代码，了解了下原理。\n\n# 刷新原理\n\n首先上拉下拉刷新肯定是基于UIScrollView的基础上的，包括UITableView其实也是一个UIScrollView。而实现上拉下拉刷新的原理就是UIScrollView中的代理方法\n\t\n\t- (void)scrollViewDidScroll:(UIScrollView *)scrollView;// any offset changes\n\n这个方法是在你的scrollView滚动时就会执行的方法。\n\n这里有必要说明下scrollView的两个属性，一个是contentSize，一个是contentOffset。这里上图片讲解可能直观一点。\n\n![挂了？！](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/iOS/scrollview.png)\n\n*PS：不会用mac的画图工具比较丑见谅。*\n\n看图，这里的绿色框就是我们的手机屏幕，我们的UI都是呈现在手机屏幕上的，那么黑色的框就是contentSize。就是说，虽然手机屏幕只有一点大，但是我们的scrollView并不是只有一点大的，这个属性是可以设置的，而我们滚动scrollView其实就是滚动黑色框，这样看到的界面就会不一样了。而图上标注的红点就是contentOffset。contentOffset是一个CGPoint，代表当前屏幕所在位置左上角相对于scrollView.contentSize左上角的横纵坐标值。\n\n了解了scrollView我们就来说刷新。在\n`- (void)scrollViewDidScroll:(UIScrollView *)scrollView;// any offset changes`方法中我们应该监听contentOffset的值，如果他的纵坐标到某个点以上我们就执行刷新数据，移动到某个点以下我们就执行加载数据。具体看代码可能更好理解。\n\n\t- (void)scrollViewDidScroll:(UIScrollView *)scrollView \n\t{\n    if ([scrollView isEqual:_tableView]) {\n        if (scrollView.contentOffset.y < -50 ) {\n        //下拉刷新方法\n        }\n        if (scrollView.contentOffset.y > 800 ) {\n        //上拉加载方法\n        }\n      }\n    }\n    \n原理很简单，但是实现的话还是有很多细节需要考虑的，比如`scrollView.contentOffset.y < -50`的情况是很多的，当用户快速上拉到-100时，可能在-51执行一次刷新方法，在-52执行一次，-53执行一次。。。。。。这肯定是不合理的。\n\n所以我们需要节流。这里提两个我的个人观点，一个是开线程执行刷新办法，如果线程存在不会新开一个，这样可以保证刷新方法执行一次。还有一种是用KVO监听用户手指松开的动作，松开的时候再刷新，或者` - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate`用这个代理方法，他会帮你监听手指是否松开。这两个方法我都没试过，大家可以自己尝试下，有错希望反馈给我，共同进步。\n\n但是如果仅仅是判定松开我觉得是满足不了需求的。我现在希望就是当用户快下滑到底部时就自动加载新数据，那我应该怎么实现呢？总不能用户一拉到底不松手就不加载吧。\n\n# RAC一个方法实现刷新\n\n我想到了RAC。这个想法可能有点非主流，所以肯定有逻辑考虑不周的地方，希望各位指出。这里我先宏定义了下，为了缩短代码\n\n\t#define VIEWHEIGHT self.view.frame.size.height\n\n然后就是RAC了。\n\n    [[[RACObserve(self.tableView, contentOffset) map:^id(id value) {\n        if (self.tableView.contentOffset.y < -50) {\n            return @\"1\";\n        }\n        if (self.tableView.contentOffset.y > self.tableView.contentSize.height - VIEWHEIGHT * 1.5 && self.tableView.contentSize.height - VIEWHEIGHT * 1.5 > 0) {\n            return @\"2\";\n        }else{\n            return @\"0\";\n        }\n    }] distinctUntilChanged] subscribeNext:^(id x) {\n        debugLog(@\"%@\", x);\n        if ([x integerValue] == 1) {\n            [self netWork];\n        }else if ([x integerValue] == 2){\n            [self loadMoreData];\n        }\n    }];\n    \n这里是用了RAC KVO的写法，不会的可以点[我文章](http://cbsfly.github.io/ios/rac1/)复习下。首先写了一个通知监听tableView的contentOffset，如果发生变化立刻进入map产生的映射中执行map中的方法。我给情况分了类，如果用户下拉，返回1，如果上拉快到底部时返回2。并且在映射完成后用了`distinctUntilChanged`属性，当我的映射值不产生变化时是不会传递映射值的。这样当用户拉倒需要刷新的位置，只会发一个信号给订阅者，只会执行一次刷新数据的方法，这样我所有的需求就迎刃而解了。\n\n如果有更好的办法希望大家给我指出，谢谢大家。","categories":["iOS"]},{"title":"摆脱第三方库系列（一）- 自己写一个侧拉菜单","url":"/2021/03/05/2016-02-23-slipview/","content":"\n# 前言\n\n一直有这么一个想法，就是摆脱第三方库来开发程序，虽然很不现实，但想尝试做一点努力。这篇文章先实现比较常见的侧拉菜单功能。\n\n# 侧拉菜单基本结构\n\n一般侧拉菜单就是一个中心页和一个侧边页构成。通过添加手势移动中心页，展示出侧边页。\n\n现在APP中常见的侧拉菜单大体可以分成两种类型的，一种是外国的APP（比如Steam，facebook）比较喜欢的分页式的侧拉菜单，就是用中心页覆盖住侧边页，然后移动中心页的时候就能展现出被中心页覆盖的侧边页；还有一种就是国内（比如知乎日报）比较喜欢的一体式侧拉菜单，侧边页放置在中心页的左边或者右边，拉动时就可展现另一页内容。下面两张图第一张是分页式，第二张是一体式。\n\n![wait](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/iOS/celapage.gif)\n\n![wait](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/iOS/celatogether.gif)\n\n# 实现侧拉菜单\n\n这篇文章将主要介绍一体式侧拉菜单的写法。\n\n先创建一个侧边页TogetherLeftView，最简单的继承于UIView的普通页面就行。在里面重写了初始化方法，改个颜色便于区分。\n\n\t- (instancetype)initWithFrame:(CGRect)frame\n\t{\n    \tself = [super initWithFrame:frame];\n   \t\tif (self) {\n    \t    self.backgroundColor = [UIColor redColor];\n    \t}\n    \treturn self;\n\t}\n\t\n然后就是中心页TogetherMainView，一般将手势写在这一页。先声明两个对象两个变量。还有宏定义侧边页的宽度\n\n\t#define LEFTVIEWWIDTH 280\n\t\n\t@interface TogetherMainView : UIView\n\t@property (nonatomic, assign) float centerX;\n\t@property (nonatomic, assign) float centerY;\n\t@property (nonatomic, strong) UIPanGestureRecognizer *panGestureRecognizer;\n\t@property (nonatomic, strong) UIButton *leftBtn;\n\t\n其中UIPanGestureRecognizer是苹果公司给的基本手势抽象类中的拖动手势，View添加这个后就可以拖动了。想学习其他基本手势的可以看看苹果UIGestureRecognizer的文档，这里不做介绍。leftBtn是点击后可以隐藏（出现）菜单的按钮。\n\n然后重写初始化方法。\n\n\t- (instancetype)initWithFrame:(CGRect)frame\n\t{\n    \tself = [super initWithFrame:frame];\n    \tif (self) {\n        \tCGRect screen = [[UIScreen mainScreen] bounds];\n        \tself.centerX = screen.size.width / 2;\n        \tself.centerY = screen.size.height / 2;\n        \n        \tself.backgroundColor = [UIColor greenColor];\n        \n        \t[self addSubview:self.leftBtn];\n        \t[self addGestureRecognizer:self.panGestureRecognizer];\n    \t}\n    \treturn self;\n\t}\n\n这里的centerX和centerY是对屏幕初始中心位置的记录，我们一会还原位置要用到。然后先看手势部分，panGestureRecognizer的get方法如下\n\n\t- (UIPanGestureRecognizer *)panGestureRecognizer\n\t{\n\t    if (_panGestureRecognizer == nil) {\n\t        _panGestureRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePan:)];\n\t    }\n\t    return _panGestureRecognizer;\n\t}\n\t\n这里给拖动时添加了一个方法handlePan，关键点就在这个方法里\n\n\t- (void)handlePan:(UIPanGestureRecognizer *)recognizer\n\t{\n\t    CGPoint translation = [recognizer \ttranslationInView:self];\n\t    float x = self.center.x + translation.x;\n\t    \n\t    if (x < _centerX) {\n\t        x = _centerX;\n\t    }\n\t    self.center = CGPointMake(x, _centerY);\n\t    \n\t    if (recognizer.state == UIGestureRecognizerStateEnded) {\n\t        [UIView animateWithDuration:0.2 animations:^(void){\n\t            if (x > (self.centerX + LEFTVIEWWIDTH/2)) {\n\t                self.center = CGPointMake(self.centerX + LEFTVIEWWIDTH, _centerY);\n\t            }else{\n\t                self.center = CGPointMake(_centerX, _centerY);\n\t            }\n\t        }];\n\t    }\n\t    [recognizer setTranslation:CGPointZero inView:self];\n\t}\n\t\n当我们在View界面中拖动时就会进入这个方法，我们先设一个CGPoint来获取每次得到的移动距离translation，然后`float x`就表示当前屏幕中心点的位置（原来的位置加上移动量）。\n\n由于我写的是一个左侧的菜单，所以中心页应该是不能左移的，假如我们左移，就会造成`x < _centerX`，那样的话旧把x设成原来的中心点centerX就行了，这样就能阻止中心页左移。（如果想阻止右移把小于改成大于就行了。\n\n然后就是在拖动效果结束（松开鼠标）时做一个判定，这里为了看起来平滑一点用了一个动画效果，如果拖动距离超过侧边页的一半旧显示出侧边页，否则还原。\n\n最后还要将recognizer置位零。因为拖动时会多次执行这个方法，如果不置零可能出错。\n\n这样最关键的部分就讲解完了，然后上按钮的动作代码，应该可以看的懂。\n\n\t- (UIButton *)leftBtn\n\t{\n\t    if (_leftBtn == nil) {\n\t        _leftBtn = [[UIButton alloc] initWithFrame:CGRectMake(20, 20, 120, 40)];\n\t        [_leftBtn setTitle:@\"点我弹出菜单\" forState:UIControlStateNormal];\n\t        [_leftBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];\n\t        [_leftBtn addTarget:self action:@selector(leftViewAppear) forControlEvents:UIControlEventTouchUpInside];\n\t    }\n\t    return _leftBtn;\n\t}\n\t\n\t- (void)leftViewAppear\n\t{\n\t    [UIView animateWithDuration:0.2 animations:^(void){\n\t        if (self.center.x == self.centerX) {\n\t            self.center = CGPointMake(self.centerX + LEFTVIEWWIDTH, self.centerY);\n\t        }else if (self.center.x == self.centerX + LEFTVIEWWIDTH) {\n\t            self.center = CGPointMake(self.centerX, self.centerY);\n\t        }\n\t    }];\n    \n\t}\n\t\n接下来就是添加到ViewController里面了，两个页面对象都要声明\n\n\t@property (nonatomic, strong) TogetherLeftView *leftView;\n\t@property (nonatomic, strong) TogetherMainView *mainView;\n\t\n这里上一下代码，不做过多解释\n\n\t- (void)viewDidLoad {\n\t    [super viewDidLoad];\n\t    [self.view addSubview:self.mainView];\n\t    [self.mainView addSubview:self.leftView];\n\t}\n\t\n\t- (TogetherMainView *)mainView\n\t{\n\t    if (_mainView == nil) {\n\t        _mainView = [[TogetherMainView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];\n\t    }\n\t    return _mainView;\n\t}\n\n\t- (TogetherLeftView *)leftView\n\t{\n\t    if (_leftView == nil) {\n\t        _leftView = [[TogetherLeftView alloc] initWithFrame:CGRectMake(-LEFTVIEWWIDTH, 0, LEFTVIEWWIDTH, [UIScreen mainScreen].bounds.size.height)];\n\t    }\n\t    return _leftView;\n\t}\n\t\n那么如何写一个分页式的侧拉菜单呢？其实主要的区别就是在ViewController中添加页面的时候用中心页将侧边页覆盖就行了，具体的代码可以去我的[github](https://github.com/cbsfly/cbsSlipView)下载来看。\n\n# 总结\n\n我想将比较常用的功能都自己动手写一遍这样更能明白底层的原理，我觉得更适合新手的学习，直接用第三方库谁都会，但哪天有需求变动要求你改你却无从下手就很尴尬了。这个系列我也会坚持下去，同样如果笔者哪里有错的地方希望大家提出来我好改正。\t","categories":["iOS"]},{"title":"摆脱第三方库系列（二）- 自己写一个滚动广告","url":"/2021/03/05/2016-02-24-rollview/","content":"\n# 前言\n\n摆脱第三方库系列第二章，我将介绍滚动广告的写法。在一些信息聚合类APP中滚动广告非常常见或者说必不可少，他可以不需要用户操作展示一些开发者想展示的东西，原理其实也很简单。我写的滚动广告主要实现自动滚动和循环滚动这两个功能，至于广告的点击事件或者美化这都是后话了。\n\n# 滚动广告基本原理\n\n其实只要是滚动的东西都离不开UISCrollView，滚动广告的原理就是在一个横向的UISCrollView上放置多张图片并插入文字，然后设置时间自动翻页，点击事件可以通过设置代理方法完成。\n\n而循环播放的原理是这样的，假使我们有五张广告图需要播放，那么我们在UISCrollView应该插入七张图片，除开头尾两张后中间剩下的五张按顺序放置我们要展示的广告，那么头尾两部分放什么呢？\n\n>头部分应该放最后一张也就是第五张广告图，尾部分应该放第一张广告图\n\n这样当用户看到第一张广告图并向左移动时就会出现第五张广告图，然后我们应该在代码中使用一些“小手段”，当广告页滚动到头页的时候应该自动跳到倒数第二页也就是第五张广告页。这样就完成了一个看起来可以循环的轮播广告了。\n\n# 代码实现\n\n先上完成效果图\n\n![wait](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/iOS/rollpage.gif)\n\n接下来上代码，先创建一个继承于UIView的子类RollView，这里不推荐直接继承于UISCrollView，那样可能会因为控件层次问题出现有些控件被覆盖了。\n\n## 接口部分\n\nRollView接口部分如下\n\n\t@interface RollView : UIView<UIScrollViewDelegate>\n\t@property (nonatomic, strong) UIScrollView *rollScrollView;\n\t@property (nonatomic, strong) NSMutableArray *imageArray;\n\t@property (nonatomic, strong) UIImageView *rollImgView;\n\t@property (nonatomic, strong) UIPageControl *pageControl;\n\t@property (nonatomic, strong) NSTimer *timer;\n\t@end\n\nUIPageControl是一个苹果公司给的页面小点的控件，也是滚动广告比较常见的需要添加的控件。而`imageArray`主要是为了存储多个广告图，可以自己封装一个UIImageView这样就可以让自己的广告更加个性了。\n\n为了简化代码先宏定义下\n\n\t#define COUNT self.imageArray.count\n\t#define SVIEWWIDTH self.frame.size.width\n\t#define SVIEWHEIGHT self.frame.size.height\n\t\n## RollView初始化\n\n先看自身的初始化方法，很简单，`addNSTimer`方法是添加一个定时器滚动，一会再介绍。\n\n\t- (instancetype)initWithFrame:(CGRect)frame\n\t{\n\t    self = [super initWithFrame:frame];\n\t    if(self){\n\t        [self addSubview:self.rollScrollView];\n\t        [self addSubview:self.pageControl];\n\t        [self addNSTimer];\n\t    }\n\t    return self;\n\t}\n\n## 各个控件get方法\n\n接下来看get方法\n\n\t- (UIScrollView *)rollScrollView\n\t{\n\t    if (_rollScrollView == nil) {\n\t        _rollScrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, SVIEWWIDTH, SVIEWHEIGHT)];\n\t        _rollScrollView.delegate = self;\n\t        _rollScrollView.contentSize = CGSizeMake((COUNT + 2) * SVIEWWIDTH, SVIEWHEIGHT);\n\t        //使子视图imageview自动适配scrollview的大小\n\t        [_rollScrollView setAutoresizesSubviews:YES];\n\t        //将scrollview设成分页形式\n\t        [_rollScrollView setPagingEnabled:YES];\n\t        //隐藏scrollview两边的滚动条\n\t        [_rollScrollView setShowsVerticalScrollIndicator:NO];\n\t        [_rollScrollView setShowsHorizontalScrollIndicator:NO];\n\t        //设置scrollview初始的位置为第二部分来显示第一张广告\n\t        _rollScrollView.contentOffset = CGPointMake(SVIEWWIDTH, 0);\n\t    }\n\t    return _rollScrollView;\n\t}\n\t\n什么是UISCrollView的contentSize我在[这篇文章](http://cbsfly.github.io/ios/rac-refresh)讲过。由于要循环播放所以要加两张图片，所以宽度为`(COUNT + 2) * SVIEWWIDTH`，其他解释写在注释里了。\n\n然后是pageControl的get方法。\n\n\t- (UIPageControl *)pageControl\n\t{\n\t    if (_pageControl == nil) {\n\t        _pageControl = [[UIPageControl alloc] initWithFrame:CGRectMake((SVIEWWIDTH - _pageControl.bounds.size.width)/2, SVIEWHEIGHT - 10, _pageControl.bounds.size.width, _pageControl.bounds.size.height)];\n\t        _pageControl.currentPageIndicatorTintColor = [UIColor whiteColor];\n\t        _pageControl.pageIndicatorTintColor = [UIColor grayColor];\n\t        [_pageControl setNumberOfPages:COUNT];\n\t    }\n\t    return _pageControl;\n\t}\n\t\n其中`currentPageIndicatorTintColor`是点移动到当前点时的颜色，`pageIndicatorTintColor`是没移动到的点的颜色。\n\n然后在`imageArray`中添加我们的广告图片，由于NSArray是可以存储任何对象类型的，所以我们可以存储广告图也可以直接存UIImageView，这里我是存了任意的五张UIImage，就不上代码了，直接看`rollImgView`。\n\n\t- (UIImageView *)rollImgView\n\t{\n\t    if (_rollImgView == nil) {\n\t        //第一个放最后一个图片\n\t        _rollImgView = [[UIImageView alloc] init];\n\t        _rollImgView.frame = CGRectMake(0, 0, SVIEWWIDTH, SVIEWHEIGHT);\n\t        [_rollImgView setImage:[_imageArray objectAtIndex:(COUNT - 1)]];\n\t        [self.rollScrollView addSubview:_rollImgView];\n\t        //最后一个放第一张图片\n\t        _rollImgView = [[UIImageView alloc] init];\n\t        _rollImgView.frame = CGRectMake(SVIEWWIDTH * (COUNT + 1), 0, SVIEWWIDTH, SVIEWHEIGHT);\n\t        [_rollImgView setImage:[_imageArray objectAtIndex:0]];\n\t        [self.rollScrollView addSubview:_rollImgView];\n        \n\t        for (int i = 0; i < COUNT; i++) {\n\t            _rollImgView = [[UIImageView alloc] init];\n\t            _rollImgView.frame = CGRectMake(SVIEWWIDTH * (i + 1), 0, SVIEWWIDTH, SVIEWHEIGHT);\n\t            [_rollImgView setImage:[_imageArray objectAtIndex:i]];\n\t            [self.rollScrollView addSubview:_rollImgView];\n\t        }\n\t    }\n\t    return _rollImgView;\n\t}\n\t\n这里需要注意的就是每个图片需要放置的frame，想不明白的自己动手画个草稿就一目了然了。我是设置了五张广告图片所以我们应该用七张UIImageView，所以要初始化七次添加七次，可能有点不合理，有更好的办法希望留言告诉我。\n\n## scrollView代理部分\n\n\t- (void)scrollViewDidScroll:(UIScrollView *)scrollView\n\t{\n\t    if (scrollView.contentOffset.x == 0) {\n\t        self.rollScrollView.contentOffset = CGPointMake(COUNT * SVIEWWIDTH, 0);\n\t        self.pageControl.currentPage = (COUNT - 1);\n\t    }else if (scrollView.contentOffset.x == (COUNT + 1) * SVIEWWIDTH){\n\t        self.rollScrollView.contentOffset = CGPointMake(SVIEWWIDTH, 0);\n\t        self.pageControl.currentPage = 0;\n\t    }else{\n\t        int pagenum = (round(scrollView.contentOffset.x/self.rollImgView.frame.size.width) - 1);\n\t        [self.pageControl setCurrentPage:pagenum];\n\t    }\n\t}\n\n\t- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView\n\t{\n\t    [self removeNSTimer];\n\t}\n\t\n\t- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\n\t{\n\t    [self addNSTimer];\n\t}\n\t\n主要代码都在`scrollViewDidScroll`方法中，就是在scrollview滚动时调用的方法。这里主要就是前面提到的实现循环滚动的“小手段”了。\n\n当`scrollView.contentOffset.x == 0`时，说明的此时显示的是头imageview即第五张广告，那么我们需要跳动到第五张广告也就是第六张imageview来完成循环效果，同时也别忘记改版pageControl的当前点。由于是5个点，那么下标是0-4，所以是标到`(COUNT - 1)`处。\n\n`scrollView.contentOffset.x == (COUNT + 1) * SVIEWWIDTH`表示的是在尾imageview时的操作。\n\n如果既不在头也不在尾，我们只需要在滚动时改变标签点就可以了。其中`round`是表示取四舍五入的整数，这样改变标签点更合理。\n\n下面两个方法是说我们鼠标按住scrollview时我们应该取消计时器不再计时，松开手时再开始计时。\n\n## 计时器\n\n\t- (void)addNSTimer\n\t{\n\t    if (self.timer == nil) {\n\t        NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:4 target:self selector:@selector(nextPage) userInfo:nil repeats:YES];\n\t        [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSRunLoopCommonModes];\n\t        self.timer = timer;\n\t    }\n\t}\n\n\t- (void)removeNSTimer\n\t{\n\t    [self.timer invalidate];\n\t    self.timer =nil;\n\t}\n\n\t- (void)nextPage\n\t{\n\t    if (self.rollScrollView.contentOffset.x == ((COUNT) * self.rollImgView.frame.size.width)) {\n\t        [self.rollScrollView scrollRectToVisible:CGRectMake(SVIEWWIDTH, 0, SVIEWWIDTH, SVIEWHEIGHT) animated:YES];\n\t    }else{\n\t        [self.rollScrollView scrollRectToVisible:CGRectMake(self.rollScrollView.contentOffset.x + self.rollImgView.frame.size.width, 0, SVIEWWIDTH, SVIEWHEIGHT) animated:YES];\n\t    }\n\t}\n\t\n这里主要是三个自定义方法，顾名思义都比较简单，这里不做详细介绍了。\n\n接下来就将RollView添加到ViewController中就可以展示了。\n\n# 总结\n\n这样滚动广告差不多就介绍完了，我只是介绍了基本原理，在我们的开发中肯定是不能完全满足需求的，所以还要加一些自定义的更改。比如用自定义的imageview并用代理方法增加点击事件，或者直接不用imageview用buttun。demo我也会放到我的[github](https://github.com/cbsfly/cbsRollView)上。\n\n还是那句话，如果有错还请指出，万分感谢。\n\n# 相关文章\n\n[摆脱第三方库系列（一）-自己写一个侧拉菜单](http://cbsfly.github.io/ios/slipview)","categories":["iOS"]},{"title":"学习RAC小记-适合给新手看的RAC用法总结","url":"/2021/03/05/2016-01-03-rac1/","content":"*最近叶大直播写代码，我也做点小笔记。*\n\n<hr />\n\n# 什么是RAC？\n\n几乎每一篇介绍RAC的文章开头都是这么一个问题。我这篇文章是写给新手（包括我自己）看的，所以这个问题更是无法忽视。\n\n简单的说，RAC就是一个第三方库，他可以大大简化你的代码过程。\n\n官方的说，[ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)（其简称为RAC）是由GitHub开源的一个应用于iOS和OS X开发的新框架。RAC具有[函数式编程](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)和[响应式编程](https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B)的特性。\n\n# 为什么我们要学习RAC？\n\n为了提高我们的开发效率。RAC在某些特定情况下开发时可以大大简化代码，并且目前来看安全可靠。\n\n# 配置RAC环境\n\n我习惯用cocoapods来安装github上得开源库，不会的新手iOS开发者有兴趣可以去学一下。\n\n想学习cocoapods的同学推荐[唐巧前辈的文章](http://devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/)。\n\n\tplatform:ios, '8.0'\n\tpod 'ReactiveCocoa','~>2.1.8'\n\n这里有一点要注意下就是RAC的版本问题，由于还没学习Swift，所以我是用OC编写程序的，最新版的RAC已经支持Swift了，但是在OC的程序安装最新版的RAC可能跑不起来，所以推荐大家使用2.5.0版本以下的RAC（具体支持Swift的版本可能有误，但我引用的2.1.8肯定是没问题的）。\n\n# 使用RAC\n\n## 1.target-action\n\nRAC最基本的入门使用技巧就是对事件的监听。\n\n*PS:在iOS开发中，我们所说的点击事件其实就是target-action，接触过iOS开发的人都不会陌生UIControlEventTouchUpInside，这就是按下并松开的动作。不仅仅是UIButton，还有UITextField也有目标-动作模式。*\n\n使用前别忘了引用头文件~\n\n\t#import <ReactiveCocoa/ReactiveCocoa.h>\n\n接下来就是最关键的RAC代码了。\n\n\t[[self.textFild rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(id x){\n        NSLog(@\"change\");\n    }];\n    \n就这么短短的两行代码。他实现了一个功能，即监听了textFild的UIControlEventEditingChanged事件，当事件发生时实现方法`NSLog`。\n所以我们就可以以这段代码为模板进行RAC的使用，举一反三，以后的UIButton点击事件我们都可以用RAC方法进行添加，再也不用`add Target`了。\n对于textFild的文字更改监听也有更简单的写法\n\n    [[self.textFild rac_textSignal] subscribeNext:^(id x) {\n        NSLog(@\"%@\",x);\n    }];\n    \n这样就是每次改变TextFild都输出改变后的结果。\n\n再比如给我们的某个label添加一个手势动作，我们也可以用简单的RAC代码完成\n\n\tUITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];\n\t[[tap rac_gestureSignal] subscribeNext:^(id x) {\n        NSLog(@\"tap\");\n    }];\n    [self.view addGestureRecognizer:tap];\n    \n这段具体我就不解释了，相信大家都能看得懂，看不懂的自己写写就懂了。\n    \n## 2.代理\n\n*用RAC写代理是有局限的，它只能实现返回值为void的代理方法*\n\n首先我们要明白我们为什么要用RAC写代理？答：简化代码！是的，的确为了简化代码，为什么我要再这里强调这个，是因为在代理方法中我深深的感受到了RAC的优点。一开始我也不愿意花功夫去学RAC，但是我师父给我举了一个例子，如果一个View里有多个AlertView，每个AlertView有很多个按钮，每个按钮都有自己的点击事件，我应该怎么写？我想了一下，不但每个按钮需要打标记，而且每个AlertView也要打标记，然后再往代理点击事件里加各种方法，代码就又臭又长。那么让我们看看RAC怎么写代理方法。\n\n    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"RAC\" message:@\"RAC TEST\" delegate:self cancelButtonTitle:@\"cancel\" otherButtonTitles:@\"other\", nil];\n    [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple *tuple) {\n        NSLog(@\"%@\",tuple.first);\n        NSLog(@\"%@\",tuple.second);\n        NSLog(@\"%@\",tuple.third);\n    }];\n    [alertView show];\n    \n我们来看RAC的语句。`@selector`是指这次事件监听的方法`fromProtocol`指依赖的代理。这里block中有一个RACTuple，他相当于是一个集合类，他下面的first，second等就是类的各个参数，我这里点了AlertView第二个按钮other输出了一下。\n\n\t2016-01-04 18:24:29.114 RACStudyTest[5003:388870] <UIAlertView: 0x7ff260c90c70; frame = (0 0; 0 0); layer = <CALayer: 0x7ff260c91030>>\n\t2016-01-04 18:24:29.115 RACStudyTest[5003:388870] 1\n\t2016-01-04 18:24:29.115 RACStudyTest[5003:388870] (null)\n\t\n可以看出`tuple.second`是ButtonAtIndex中Button的序号。那么对于上面那个我举的例子，就可以用`switch`给各个按钮添加方法，这样的代码看起来更容易理解，方面后期维护。\n\n当然了，AlertView代理也有简化的代码。\n\n    [[alertView rac_buttonClickedSignal] subscribeNext:^(id x) {\n        NSLog(@\"%@\",x);\n    }];\n    \n这里的x就是各个Button的序号了，可以直接应对我上述遇到的问题。\n\n## 3.通知\n\n在我们的开发中通知也是一个比较常用的功能，主要的应用场景是某个页面进行数据重传需要更新model但是点击返回栈时不会刷新返回界面的数据，这时就可以用通知来更新另一个页面的数据，当然我们也可以在另一个页面的`ViewDidAppear`方法中刷新数据，但那是题外话。\n\n这里写的Demo就是我上述说的情况。\n\n首先，在某个页面中我们需要发出通知，这里就是最基本的通知的写法。发送名为postdata的通知并传送一个数组dataArray。\n\n    NSMutableArray *dataArray = [[NSMutableArray alloc] initWithObjects:@\"1\", @\"2\", @\"3\", nil];\n    [[NSNotificationCenter defaultCenter] postNotificationName:@\"postData\" object:dataArray];\n    \n而在接受的页面我们需要增加观察者并接受数组，这时我们的RAC就派上用场了。\n\n    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:@\"postData\" object:nil] subscribeNext:^(NSNotification *notification) {\n        NSLog(@\"%@\", notification.name);\n        NSLog(@\"%@\", notification.object);\n    }];\n    \n当这个页面监听到名为postdata的通知时他就会执行block中的方法，当然这里的参数改成`id x`也是可以的，这里用NSNotification主要是强调它的类型。让我们看看控制台的输出。\n\n\t2016-01-04 20:10:52.274 RACStudyTest[5918:439077] postData\n\t2016-01-04 20:10:52.275 RACStudyTest[5918:439077] (\n    1,\n    2,\n    3\n\t)\n\n可见，notification.object就是我们想要的数组，当然我们也可以传一些model。值得一提的是，**RAC中的通知不需要`remove observer`，**因为在rac_add方法中他已经写了remove。\n\n## 4.KVO\n\nRAC中得KVO大部分都是宏定义，所以代码异常简洁，简单来说就是`RACObserve(TARGET, KEYPATH)`这种形式，TARGET是监听目标，KEYPATH是要观察的属性值，这里举一个很简单的例子，如果UIScrollView滚动则输出success。\n\n    UIScrollView *scrolView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, 200, 400)];\n    scrolView.contentSize = CGSizeMake(200, 800);\n    scrolView.backgroundColor = [UIColor greenColor];\n    [self.view addSubview:scrolView];\n    [RACObserve(scrolView, contentOffset) subscribeNext:^(id x) {\n        NSLog(@\"success\");\n    }];\n    \n如果你好好回顾下KVO的写法会不会更加感叹RAC的强大呢？\n\n# 总结\n\nRAC的东西很多，但相信这篇文章给大家入门还是可以的，这里介绍了RAC得基本使用方法，但是还有很多好用的东西比如信号都没介绍，甚至除了subscribeNext还有subscribeComplete和subscribeError，这些都是我给自己留得坑，以后也会发文介绍给大家。","categories":["iOS"]},{"title":"探究RAC-RAC信号处理方法归纳","url":"/2021/03/05/2016-01-06-rac2/","content":"*继续完成RAC的坑*\n\n<hr />\n\n# 前言\n\n经过[上篇文章](http://cbsfly.github.io/ios/rac1/)的学习，相信不少读者已经熟悉了RAC的基本用法，可以尝试在以后的开发中不用`add target`语句了。这篇文章将稍微深入一点了解RAC的更多功能以及适用场合。\n\n# 什么是信号\n\nRAC的核心就是信号，即`RACSignal`。\n\n>信号可以看做是传递信号的工具，当数据变化时，信号就会发送改变的信息，以通知信号的订阅者执行方法。\n\n## 热/冷信号\n\n>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。\n\n## 自己动手写一个RACSignal\n\n\t//创建信号\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [subscriber sendNext:@\"signal\"];\n        [subscriber sendCompleted];\n        return nil;\n    }];\n    \n    //订阅信号\n    [signal subscribeNext:^(id x) {\n        NSLog(@\"x = %@\", x);\n    } error:^(NSError *error) {\n        NSLog(@\"error = %@\", error);\n    } completed:^{\n        NSLog(@\"completed\");\n    }];\n    \n这是一个信号从创建到接收的完整过程，我们接下来看看控制台输出了什么。\n\n\t2016-01-05 14:33:06.106 RACStudyTest[895:38671] x = signal\n\t2016-01-05 14:33:06.106 RACStudyTest[895:38671] completed\n\n可以看到，创建信号时我们sent了一个signal，在我们订阅`subscribeNext`时存储在x中的就是这个字符串signal。从这里看出来，不但我们可以给订阅者传递字符串，只要是一个类一个对象我们都可以传递。\n\n另一方面控制台输出了completed说明订阅信号部分的completed块下得方法也被执行了，这是因为饿哦在创建时发送完signal后又发送了一个completed。同理，error下得方法我们也可以这样调用。\n\n融汇贯通一下，我们之前学的所有RAC的用法就是一个创建信号订阅信号的过程！\n\n# 信号的处理\n\n## map\n\n这里的map不是地图，而是映射的意思，就是创建一个订阅者的映射并且返回数据，具体用法我们来看代码。\n\n    [[self.textFild.rac_textSignal map:^id(id value) {\n        NSLog(@\"%@\", value);\n        return @1;\n    }] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n\n在TextFild控件中输入good，输出：\n\n\t2016-01-05 15:02:15.180 RACStudyTest[1418:57245] 1\n\t2016-01-05 15:02:21.710 RACStudyTest[1418:57245] g\n\t2016-01-05 15:02:21.711 RACStudyTest[1418:57245] 1\n\t2016-01-05 15:02:22.954 RACStudyTest[1418:57245] go\n\t2016-01-05 15:02:22.955 RACStudyTest[1418:57245] 1\n\t2016-01-05 15:02:23.464 RACStudyTest[1418:57245] goo\n\t2016-01-05 15:02:23.464 RACStudyTest[1418:57245] 1\n\t2016-01-05 15:02:23.705 RACStudyTest[1418:57245] good\n\t2016-01-05 15:02:23.705 RACStudyTest[1418:57245] 1  \n\n还是之前那个监听textfild编辑变化的例子，可以看到，当信号被订阅变成热信号后，这里的map构造的映射块value的值就是控件中的字符变化，而订阅者x的值就是映射者的返回值1。\n\n根据这个功能我们就可以对我们监测的东西和我们需求的东西进行转换。比如监听了字符串变化，我们需要的时变化后的字符串长度而不是变化的字符串本身，则可以在map的返回值中返回`text.length`，就可以实时捕获到字符串长度；甚至做一个映射表，将各个变化进行一对一或者一对多或者多对一的处理。\n\n## filter\n\nfilter就是过滤，它可以帮助你筛选出你需要的信号变化。\n\n    [[self.textFild.rac_textSignal filter:^BOOL(NSString *value) {\n        return [value length] > 3;\n    }] subscribeNext:^(id x) {\n        NSLog(@\"x = %@\", x);\n    }];\n\n输入goodnight，输出：\n\n\t2016-01-05 15:18:20.492 RACStudyTest[1490:66721] x = good\n\t2016-01-05 15:18:27.917 RACStudyTest[1490:66721] x = goodn\n\t2016-01-05 15:18:28.129 RACStudyTest[1490:66721] x = goodni\n\t2016-01-05 15:18:28.433 RACStudyTest[1490:66721] x = goodnig\n\t2016-01-05 15:18:28.930 RACStudyTest[1490:66721] x = goodnigh\n\t2016-01-05 15:18:29.155 RACStudyTest[1490:66721] x = goodnight\n\t\n上述例子是在字符串长度大于3时才会输出变换后的字符串。\n\n## take/skip/repeat\n\ntake是获取，skip是跳过，这两个方法后面跟着的都是NSInteger。所以`take 2`就是获取前两个信号，`skip 2`就是跳过前两个。repeat是重复发送信号。\n\n    RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [subscriber sendNext:@\"1\"];\n        [subscriber sendNext:@\"2\"];\n        [subscriber sendNext:@\"3\"];\n        [subscriber sendNext:@\"4\"];\n        [subscriber sendNext:@\"5\"];\n        [subscriber sendCompleted];\n        return nil;\n    }] take:2];\n    \n    [signal subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }completed:^{\n        NSLog(@\"completed\");\n    }];\n    \n这个demo只会输出前两个信号1和2还有完成信号completed，skip,repeat同理。\n\n相似的还有`takeLast` `takeUntil` `takeWhileBlock` `skipWhileBlock` `skipUntilBlock` `repeatWhileBlock`都可以根据字面意思来理解。\n\n\n## delay\n\n延时信号，顾名思义，即延迟发送信号。\n\n    RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [subscriber sendNext:@\"delay\"];\n        [subscriber sendCompleted];\n        return nil;\n    }] delay:2];\n    \n    NSLog(@\"tag\");\n    \n    [signal subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n    \n输出：\n\n\t2016-01-05 15:27:55.908 RACStudyTest[1543:71256] tag\n\t2016-01-05 15:27:58.102 RACStudyTest[1543:71256] delay\n\t\n看时间可以发现订阅者延迟了2秒才收到信号打印出x的值。*PS：还有0.2s误差是因为运行到不同代码行的时间差*\n\n## throttle\n\n节流，在我们做搜索框的时候，有时候需求的时实时搜索，即用户每每输入字符，view都要求展现搜索结果。这时如果用户搜索的字符串较长，那么由于网络请求的延时可能造成UI显示错误，并且多次不必要的请求还会加大服务器的压力，这显然是不合理的，此时我们就需要用到节流。\n\n    [[[self.textFild rac_textSignal] throttle:0.5] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n\n加了节流管道，后面跟上了类型为NSTimeInterval的参数后，只有0.5S内信号不产生变化才会发送请求，这样快速的输入也不会造成多次输出。\n\n## distinctUntilChanged\n\n网络请求中为了减轻服务器压力，无用的请求我们应该尽可能不发送。`distinctUntilChanged`的作用是使RAC不会连续发送两次相同的信号，这样就解决了这个问题。\n\n    [[[self.textFild rac_textSignal] distinctUntilChanged] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];   \n\n## timeout\n\n超时信号，当超出限定时间后会给订阅者发送error信号。\n\n    RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{\n            [subscriber sendNext:@\"delay\"];\n            [subscriber sendCompleted];\n        }];\n        return nil;\n    }] timeout:2 onScheduler:[RACScheduler mainThreadScheduler]];\n    \n    [signal subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    } error:^(NSError *error) {\n        NSLog(@\"%@\", error);\n    }];\n    \n输出：\n\n\t2016-01-05 15:41:58.686 RACStudyTest[1604:76716] Error Domain=RACSignalErrorDomain Code=1 \"The operation couldn’t be completed. (RACSignalErrorDomain error 1.)\"\n\t\n由于在创建信号是限定了延迟3秒发送，但是加了timeout2秒的限定，所以这一定是一个超时信号。这个信号被订阅后，由于超时，不会执行订阅成功的输出x方法，而是跳到error的块输出了错误信息。timeout在用RAC封装网络请求时可以节省不少的代码量。\n\n## ignore\n\n忽略信号，指定一个任意类型的量（可以是字符串，数组等），当需要发送信号时讲进行判断，若相同则该信号会被忽略发送。\n\n    [[[self.textFild rac_textSignal] ignore:@\"good\"] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n    \n# 总结\n\n这篇文章比上一篇稍稍深入了RAC的附加功能，但还有很多例如扁平映射`flattenMap`，Signal of Signals都没有提到，RAC的东西实在太多太多，我说的也仅仅是九牛一毛。我将继续研究RAC的深入用法，并发文给大家介绍。如果文中有什么错误，也希望大家给我指出来，我将万分感谢。","categories":["iOS"]},{"title":"浅谈Objectiv-C中的Block","url":"/2021/03/05/2016-01-10-block/","content":"# 前言\n\n由于“业务”需求，最近我准备复习下Objective-C中的“块”，也就是大家并不陌生的block，顺便做点小笔记。说实话，其实自己之前对block不是很熟悉，所以这篇文章主要是基础知识，不会涉及太多深层次的东西，个人认为给自己也就是刚接触iOS开发的新手看看还是有作用的。\n\n# 理解Block\n\n在《Learning Cocoa with Objective-C》这本书中说我们可以把block看作是一个变量（variables），但这个变量和一般的变量有一点不同，它不像别的变量可能存储一个整型数或者字符串，它存储的是一段代码。我觉得这个理解很不错，以后我们遇到了block，不妨**将block看作一个变量**。\n\n# 如何看懂一个block？\n\n要读懂，我们首先要会写block。block的声明大致可以分为下面五种形式。\n\n## 1.block作为局部变量\n\n\treturnType (^blockName)(parameterTypes) = ^returnType(parameters) {code};\n\n这种形式可以看作最基本的block声明形式，最好动手在自己的Xcode中敲一敲。\n\n## 2.block作为接口部分属性指令\n\n\t@property (nonatomic, copy) returnType (^blockName)(parameterTypes);\n\n## 3.block作为某个方法的形式参数\n\n\t-(void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName;\n\n## 4.block作为一个被调用的方法\n\n\t[someObject someMethodThatTakesABlock:^returnType (parameters) {code}];\n\n## 5.宏定义\n\n\ttypedef returnType (^TypeName)(parameterTypes);\n\tTypeName blockName = ^returnType(parameters) {...};\n\n看完后相信读者和笔者都有一个感觉就是OC中得block非常反人类。但是我们还是可以做一些总结，比如任何情况下block的返回类型都不会单独在一对括号里；block所需要的形参都是单独在括号中的且括号之前没有^符号。^符号可以说是block的标志，凡是看到^符号就可以认为这是一个block，且括号内的一般式参数类型或者参数名，极少数情况会是block的名字（一般很少情况下会必须给block起名字，所以很多block是没有名字的）。至于block的调用方法是与函数的调用方法一致的。\n\n这么复杂的定义为何我们还要去学呢？因为block的作用其实非强大。block可以说是OC中**实现函数式编程的基础**。当我们写一个动画的过程时需要使用block；当我们需要回调网络请求的时候需要block；当我们需要更新UI的时候我们需要block。\n\n# block是如何运行的？\n\n我们先来看一个简单的demo。\n\n\t//声明一个block \n    void (^block)() = ^void (){\t //Step.1\n        NSLog(@\"1\");\t//Step.3\n    };\n    //调用block \n    block();\t\t//Step.2\n\n输出很简单就是一个1.为什么要举这个demo呢？我们不妨打个断点来看看。令人惊奇的是，在遇到block的时候我们的代码不是从上往下运行了，当执行到Step.1时函数不再往下执行NSLog方法而是到了Step.2，而Step.2调用了block函数此时才执行块中得NSLog也就是Step.3。\n\n所以上文就说了，我们应该把block看作是一个变量。当我们定义了一个`int x`的时候编译程序不会在乎你x的值是什么，而当你要用x做输出或者加减法的时候编译程序才会在内存空间中取出x进行运算。block也是这个道理。\n\n但我们也不能把Block简单的当做是一个变量，我们来看下一个demo；\n\n    int x = 10;\n    \n    void (^block)() = ^void (){\n        NSLog(@\"%d\", x);\n    };\n    \n    block();\n    x = 11;\n    block();\n\n结果两个调用block输出都是10。这就是我们常说的[闭包](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))。\n\n>\n在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的 函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。\n\n可以认为，在调用block内部函数时，里面的变量值就是block创建时变量的值。block可以看作是一个封闭的块，一个“不受外界干扰”的块。\n\n**在我们的实际开发中，我们就是要利用block的回调特性和闭包特性。**\n\n# block的应用\n\n## 1.网络请求\n\n在网络请求中，block主要是处理网络请求的返回值。一个网络请求不仅有返回数据的情况，也有超时或者链接错误等失败情况，这时我们就需要block。\n\n    [SomeClass getURL:someURL finished:^(NSData * data,NSURLResponse *response,NSError *error) {\n            if (error) {\n            ...\n        }else{\n            if (success) {\n                ...\n            }\n        }\n\t}];\n\n为什么这里要用block呢？这里偷懒引用下美团的原文。（其实是怕我自己的理解有误）\n\n>这里网络请求是异步的，所以当block中代码执行时，getURL:finished:方法调用所在的栈很可能已经不存在了，但是因为回调block和someURL构成了closure，所以即使栈不存在，block仍然可以引用到someURL。\n\n>可能你会说，“我在block中增加一个NSURL类型的参数，把someURL传回来不也可以实现同样的目的吗？”不妨设想如果我们在block中要引用的对象有10个之多，用参数列表传递明显不再现实，用容器类或者专门定义一个类来传递虽然可以，但是前者没有编译器为我们检查错误，后者则相当繁琐。而利用闭包，可以轻易达到灵活性和简洁性的平衡。事实上，美团客户端就大量利用了闭包，在UI层发出请求，在回调中更新某些UI组件。\n\n而再获取了数据之后，我们还可以直接在块中进行操作，例如更新UI，例如存储model，甚至错误的弹框。\n\n## 2.动画\n\n    UIView *ppview = [[UIView alloc] initWithFrame:CGRectMake(0, SCREENHEIGHT/2-50, 50, 50)];\n    ppview.backgroundColor = [UIColor yellowColor];\n    [self.view addSubview:ppview];\n    [UIView animateWithDuration:1.0f animations:^{\n        ppview.frame = CGRectMake(SCREENWIDTH, SCREENHEIGHT/2-50, 50, 50);\n    } completion:^(BOOL finished) {\n        ppview.frame = CGRectMake(SCREENWIDTH/2-25, SCREENHEIGHT/2-50, 50, 50);\n    }];\n    \n这里为了使代码看起来简洁用了宏定义，所以代码前要加两句话\n\n\t#define SCREENWIDTH [UIScreen mainScreen].bounds.size.width\n\t#define SCREENHEIGHT [UIScreen mainScreen].bounds.size.height\n\t\n动画的具体效果大家可以自己看，这不是重点。动画部分主要利用了块可以存储代码这一特性，使得动画的代码更简洁易懂。试想若不用block，先不管能不能实现动画效果，每个动画添加一个方法，可能一个简单的动画将有大量的代码。\n\n# 总结\n\n写这篇文章深深感受到自己的基础知识的不够用，其实自己写文的初衷也是想自己踏踏实实的学习iOS开发，写文对知识的总结还是很有效果的。\n\n由于理解不到位，block的应用那一节可能说的不是很好，希望有错的部分大家一定要帮我指出来，我一定虚心接受。\n\n# 参考文章\n\n[How Do I Declare A Block in Objective-C?](http://fuckingblocksyntax.com/)\n\n[block在美团iOS的实践](http://tech.meituan.com/block-in-Meituan-iOS.html)","categories":["iOS"]}]