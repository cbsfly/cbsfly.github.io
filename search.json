[{"title":"Goland 查引用时过滤 test 文件","url":"/2022/04/22/2022-04-21-notestfind/","content":"\n在使用 Goland 看代码的过程中，经常使用查看代码引用点的功能，但是在查阅大型项目源码时，引用大部分为 test 文件的，导致看代码逻辑效率很低。\n\n<!--more-->\n\n其实可以在查找引用时指定 scope 来过滤 test 文件，以 K8s 源码项目为例\n\n普通的查找会有很多 test 文件\n\n![1](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/2022-4-20/1.jpg)\n\n然后我们只要按照下图，设置查找 scope 就可以过滤 test 文件了\n\n`!file[kubernetes]:*//*test*&&!file[kubernetes]:test//*`\n\n![2](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/2022-4-20/2.jpg)\n\n![3](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/2022-4-20/3.jpg)\n\n![4](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/2022-4-20/4.jpg)\n\n查找效果如下\n\n![5](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/2022-4-20/5.jpg)","tags":["Goland"],"categories":["IDE"]},{"title":"envtest 安装踩坑笔记","url":"/2022/04/20/2022-04-20-testenv/","content":"\n[`controller-runtime/pkg/envtest`](https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/envtest) 使我们在写单测的时候可以不依赖 K8s 组件（API Server、Kubelet 等）去模拟 K8s 资源。\n\n本文对于自己在 Mac 环境下安装 envtest 过程遇到的坑做一些记录。\n\n<!--more-->\n\n### Kubebuilder 安装\n\nhttps://book.kubebuilder.io/quick-start.html\n\n- 注意不同的 go 版本对应不同的 kubebuilder 版本\n\n  - [go](https://golang.org/dl/) version v1.15+ (kubebuilder v3.0 < v3.1).\n  - [go](https://golang.org/dl/) version v1.16+ (kubebuilder v3.1 < v3.3).\n  - [go](https://golang.org/dl/) version v1.17+ (kubebuilder v3.3+).\n\n- 如果要完整运行 kubebuilder 实例需要提前安装好 [kustomize](https://kubernetes-sigs.github.io/kustomize/) 和 [controller-gen](https://github.com/kubernetes-sigs/controller-tools)，但如果知识需要使用 envtest 不需要\n\n- 安装步骤如下\n\n  ```shell\n  curl -L -o kubebuilder https://go.kubebuilder.io/dl/latest/$(go env GOOS)/$(go env GOARCH)\n  chmod +x kubebuilder && mv kubebuilder /usr/local/bin/\n  ```\n\n- 预置 shell 命令\n\n  ```shell\n  kubebuilder completion <bash|zsh|fish>\n  ```\n\n### envtest 安装\n\n- 安装 envtest 二进制\n\n  - 并不是每个 K8s 版本都有对应的 envtest，所以建议浏览器访问下载 https://go.kubebuilder.io/test-tools/{K8S_VERSION}/darwin/amd64\n  - 1.20 与 1.21 版本有问题，推荐使用1.19.2代替\n\n  ```shell\n  export K8S_VERSION=1.21.2\n  curl -sSLo envtest-bins.tar.gz \"https://go.kubebuilder.io/test-tools/${K8S_VERSION}/$(go env GOOS)/$(go env GOARCH)\"\n  ```\n\n- 解压二进制\n\n  - 这些二进制就是模拟的 etcd、apiserver 等组件\n  - 本地跑 UT 时不一定有权限访问这些二进制，如果不在意安全的话建议改成 777\n\n  ```shell\n  mkdir /usr/local/kubebuilder\n  tar -C /usr/local/kubebuilder --strip-components=1 -zvxf envtest-bins.tar.gz\n  ```\n\n- 执行单测时，为防止二进制路径错误，可以指定二进制跑测试\n\n  ```shell\n  make test SKIP_FETCH_TOOLS=1 KUBEBUILDER_ASSETS=/usr/local/kubebuilder/bin\n  ```\n\n  \n\n","tags":["Kubebuilder","controller-runtime"],"categories":["Kubernetes"]},{"title":"K8s Pod 何时会被删除？","url":"/2021/12/23/2021-12-23-deletepod/","content":"\n最近在梳理 Kubelet 的源码实现，从源码入手整理了下 Kubelet 以及 kube-controller 删除 Pod 的场景。\n\n本文K8s版本参考v1.20.6\n\n<!--more-->\n\n### Kube-Controller\n\n#### workload controller 触发删除\n\n- [job](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/controller/job/job_controller.go)\n  - 如果 job 处于 failed 状态，删除所有 activePod（[`deleteJobPods`](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/controller/job/job_controller.go#L522)）\n  - 如果 activePod 大于 job.Spec.Parallelism 并行数，删除多余 Pod（[`manageJob`](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/controller/job/job_controller.go#L687)）\n- [daemonset](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/controller/daemon/daemon_controller.go)\n  - 根据 taints、资源、selector 等条件判断 Pod 是否需要运行在某节点上，如果不需要则调用 [`syncNodes`](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/controller/daemon/daemon_controller.go#L917) 删除\n- [replicaset](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/controller/replicaset/replica_set.go)\n  - 根据实际的 Pod 数与 Spec 的 Pod 数比较，如果多了就调用删除 Pod（[`manageReplicas`](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/controller/replicaset/replica_set.go#L541)）\n\n- replication\n  - rc 已基本不使用\n- [statefulset](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/controller/statefulset/stateful_pod_control.go)（主要在更新函数[`updateStatefulSet`](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/controller/statefulset/stateful_set_control.go#L74)中）\n  - 状态是 failed 的 Pod 删除重建\n  - 缩容时按照顺序删除 Pod\n  - 如果版本号旧的 Pod 也删除\n\n#### NodeController 触发删除\n\nnodeController主要通过污点导致Pod的删除\n\n- K8s Admission 为所有 Pod 打上Toleration\n\n  - [DefaultTolerationSeconds admission ](https://kubernetes.io/zh/docs/reference/access-authn-authz/admission-controllers/#defaulttolerationseconds)为所有 Pod 打上 NotReady 的 NoExecute 容忍，容忍时间是 5 分钟（如果之前没有相同 KEY 的污点的话）\n  - 源码参考：plugin/pkg/admission/defaulttolerationseconds/admission.go\n\n- 节点不可用时\n\n  - 对于 NotReady 的 Node，NodeController 会自动打上污点\n\n    ```yaml\n      taints:\n      - effect: NoSchedule\n        key: node.kubernetes.io/not-ready\n        timeAdded: \"2021-12-02T10:08:44Z\"\n      - effect: NoExecute\n        key: node.kubernetes.io/not-ready\n        timeAdded: \"2021-12-02T10:08:47Z\"\n    ```\n\n  - NoExecute 污点与 `TaintBasedEvictions` 特性相关；monitorNodeHealth 会长期检查 Node 状态，如果 NotReady，会调用 processTaintBaseEviction.markNodeForTainting 将该 Node 加入 zoneNoExecuteTainter 队列，doNoExecuteTaintingPass 会周期循环这个队列打上对应的污点\n\n  - NoSchedule 污点为 doNoScheduleTaintingPass 函数打的，启用了 `TaintNodeByCondition` feature-gates 后，nodeUpdate 后会根据 Node 的 Condition 打上对应的污点，映射关系如下：\n\n    ```go\n    v1.NodeReady: {\n       v1.ConditionFalse:   v1.TaintNodeNotReady,\n       v1.ConditionUnknown: v1.TaintNodeUnreachable,\n    },\n    v1.NodeMemoryPressure: {\n       v1.ConditionTrue: v1.TaintNodeMemoryPressure,\n    },\n    v1.NodeDiskPressure: {\n       v1.ConditionTrue: v1.TaintNodeDiskPressure,\n    },\n    v1.NodeNetworkUnavailable: {\n       v1.ConditionTrue: v1.TaintNodeNetworkUnavailable,\n    },\n    v1.NodePIDPressure: {\n       v1.ConditionTrue: v1.TaintNodePIDPressure,\n    },\n    ```\n\n  - 源码参考：pkg/controller/nodelifecycle/node_lifecycle_controller.go\n\n- Pod 容忍时间达到5分钟后，Pod 被 taintManager 驱逐\n\n  - 源码参考：pkg/controller/nodelifecycle/scheduler/taint_manager.go 的 processPodOnNode\n\n  - 驱逐逻辑参考：https://kubernetes.io/zh/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-based-evictions\n\n#### Pod GC Controller\n\n- pkg/controller/podgc/gc_controller.go\n  - [gcTerminated](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/controller/podgc/gc_controller.go#L127)\n    - 根据创建时间排序，删除大于 kube-controller-manager `terminated-pod-gc-threshold` 配置（我们数据面集群配置 12500 ）个数的 Pod\n  - [gcOrphaned](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/controller/podgc/gc_controller.go#L160)\n    - 删除 bind node 不存在的 Pod\n  - [gcUnscheduledTerminating](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/controller/podgc/gc_controller.go#L223)\n    - 遍历所有pods，过滤那些terminating(`pod.DeletionTimestamp != nil`)并且未调度成功的(pod.Spec.NodeName为空)的pods\n\n### Kubelet\n\nKubelet 不会主动调用 client-go 删除 Pod，只会在 APIServer 收到 Pod 优雅删除请求后，如果 Pod 所占用的 cgroups、volume 等资源都释放了，则会调用强制删除接口（*GracePeriodSeconds 为 0*）删除 Pod\n\n以下三种情况会触发 SyncPodKill 事件，此时 Kubelet 会调用 CRI stop running container\n\n- [驱逐](https://github.com/kubernetes/kubernetes/blob/v1.20.6/pkg/kubelet/eviction/eviction_manager.go#L569)（https://kubernetes.io/zh/docs/concepts/scheduling-eviction/node-pressure-eviction/）\n\n  > - kubelet 具有以下默认硬驱逐条件：\n  >   - memory.available<100Mi\n  >   - `nodefs.available<10%`\n  >   - `nodefs.available<10%`\n  >   - `imagefs.available<15%`\n  >   - `nodefs.inodesFree<5%`（Linux 节点）\n  >   - imagefs.inodesFree、pid.available 未配置\n\n- 抢占（https://kubernetes.io/zh/docs/concepts/scheduling-eviction/pod-priority-preemption/）\n  - PriorityClass 还有两个可选字段：`globalDefault` 和 `description`。 `globalDefault` 字段表示这个 PriorityClass 的值应该用于没有 `priorityClassName` 的 Pod。 系统中只能存在一个 `globalDefault` 设置为 true 的 PriorityClass。 如果不存在设置了 `globalDefault` 的 PriorityClass， 则没有 `priorityClassName` 的 Pod 的优先级为零。\n  - 当没有悬决 Pod，或者悬决 Pod 的优先级等于或低于牺牲者时，不得发生抢占。\n  - Kube-controller-manager 等三大件优先级高。\n\n- 节点 shutdown （pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go processShutdownEvent）","tags":["Kubelet"],"categories":["Kubernetes"]},{"title":"K8s Pod 状态何时会为 Failed","url":"/2021/11/30/2021-11-30-kubelet/","content":"\n最近在梳理 Kubelet 的源码实现，整理了下 Pod 状态转换的逻辑。\n\n### Kubelet 介绍\n\nKubelet 主要负责 Pod 状态的维护和更新，其中触发同步事件的来源有三种\n\n- api：指 watch apiserver 获得的更新\n- file：static pod 场景\n- http：static pod 场景\n\n<!--more-->\n\nKubelet 主要分为以下模块\n\n- PLEG\n\n  - 即Pod Lifecycle Event Generator。其维护着存储Pod 信息的cache，从运行时获取容器的信息，并根据前后两次信息对比，生成对应的PodLifecycleEvent，通过eventChannel发送到kubelet syncLoop进行消费，最终由kubelet syncPod完成Pod的同步，维护着用户的“期望”。\n\n- ProberManager\n\n  - 负责探测 Pod 状态，主要的状态来源就是 ProberManager。\n\n- StatusManager\n\n  - 负责将 Pod 状态同步致 APIServer。\n\n- VolumeManager\n\n  - 维护真实挂载与期望挂载的一致性。\n\n- PodManager\n\n  - PodManager 在 Kubelet 中负责内存中 Pod 及 mirrorPod 的维护，任何在本节点上创建或删除操作都会同步更新 PodManager，即可以认为 PodManager 中存储了本节点上运行的 Pod 的信息。这里要对mirrorPod 做下说明，在 kubernetes 中，如果是 static pod，则由 Kubelet 直接创建，这时系统很难管理这部分 Pod；所以系统会在 Kubelet 中创建一个 static pod 对应的 mirrorPod，来表示 static pod。\n\n- PodWorkers\n\n  处理 Pod 同步。核心方法 `managePodLoop()` 间接调用 [`kubelet.syncPod()`](https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kubelet.go#L1540) 完成 Pod 的同步\n\n  - 如果 Pod 正在被创建，记录其延迟\n  - 生成 Pod 的 API Status，即 `v1.PodStatus`：从运行时的 status 转换成 api status\n  - 记录 Pod 从 `pending` 到 `running` 的耗时\n  - 在 `StatusManager` 中更新 pod 的状态\n  - 杀掉不应该运行的 Pod\n  - 如果网络插件未就绪，只启动使用了主机网络（host network）的 Pod\n  - 如果 static pod 不存在，为其创建镜像（Mirror）Pod\n  - 为 Pod 创建文件系统目录：Pod 目录、卷目录、插件目录\n  - 使用 `VolumeManager` 为 Pod 挂载卷\n  - 获取 image pull secrets\n  - 调用容器运行时（container runtime）的 `#SyncPod()` 方法\n\n### 何时会进行 Pod 状态刷新？\n\n- 一般情况下是 ProbeManager 会定时探测 container 的状态（如未配置 ReadinessProbe，默认上报 Success），然后调用 StatusManager 接口刷新到 APIServer，最终展示给用户。\n- 某些特殊场景会直接修改 Pod 状态，如 Pod 被驱逐，节点关闭等。\n\n### 何时 Pod 会失败？\n\n以下情况会修改 Pod Phase 为 Failed。\n\n- Pod Phase 是否为 Failed 由 containerStatus.State 决定（[源码参考](https://github.com/kubernetes/kubernetes/blob/release-1.20/pkg/kubelet/kubelet_pods.go#L1378)）。\n  - initContainers 中某个 Container 为 Terminated 或者 Waiting（LastTerminationState.Terminated 不为空），且 Exsit Code 不等于0。\n  - 所有 containers **都为** Terminated 或者 Waiting（LastTerminationState.Terminated 不为空），且存在一个以上 Pod Exsit Code 不等于0，此时如果 Pod 重启策略为 RestartPolicyNever，则会将 Pod Phase 置为 Failed。\n- 其他特殊场景\n  - Pod 遭驱逐时（spec.activeDeadlineSeconds 被设置且到期或资源不够被抢占或 API 调用）（[源码参考](https://github.com/kubernetes/kubernetes/blob/release-1.20/pkg/kubelet/kubelet_pods.go#L1488) & [源码参考](https://github.com/kubernetes/kubernetes/blob/release-1.20/pkg/kubelet/preemption/preemption.go#L93) & [源码参考](https://github.com/kubernetes/kubernetes/blob/release-1.20/pkg/kubelet/eviction/eviction_manager.go#L569)）。\n  - 创建 Pod 时准入检查失败（[源码参考](https://github.com/kubernetes/kubernetes/blob/release-1.20/pkg/kubelet/kubelet.go#L2075)）。\n  - 节点 shutdown 时（[源码参考](https://github.com/kubernetes/kubernetes/blob/release-1.20/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go#L220)）。\n\n### 参考文档\n\nhttps://cloud.tencent.com/developer/article/1768567\n\nhttps://jishuin.proginn.com/p/763bfbd364d5\n\nhttps://jishuin.proginn.com/p/763bfbd36b91\n\nhttps://mp.weixin.qq.com/s/sphh9audcToHQvwhe3Otng\n\nhttps://jishuin.proginn.com/p/763bfbd37488\n\nhttps://cloud.tencent.com/developer/article/1791692?from=article.detail.1768567\n\nhttps://fankangbest.github.io/2017/12/18/kubelet%E5%88%86%E6%9E%90(%E4%BA%94)-podManager-v1-5-2/\n\nhttps://cizixs.com/2017/06/12/kubelet-source-code-analysis-part4-status-manager/\n\nhttps://cloud.tencent.com/developer/article/1559761\n\nhttps://www.kubernetes.org.cn/7263.html\n\nhttps://segmentfault.com/a/1190000040174600\n\n","tags":["Kubelet"],"categories":["Kubernetes"]},{"title":"Client-go 的 UpdateStatus 接口你用对了吗？","url":"/2021/11/25/2021-11-25-update-status/","content":"\n最近发现一个问题，发现使用 client-go 并行调用 UpdateStatus 接口与 PATCH 更新 annotation 会出现覆盖写的问题，这与之前的理解不一致，这里做一个记录。\n\n先说结论：client-go 的 UpdateStatus 会 PUT 更新 Pod 的 Status 字段与 metadata 字段。\n\n<!--more-->\n\n### 问题现象\n\n使用 client-go 在两个协程并行调用 UpdateStatus 接口与 PATCH 接口更新 annotation，发现 annotation 更新失效。\n\n### 问题分析\n\n通过打印 client-go 的 response body 信息（klog 的 flag 设置 v=8 以上），发现两个协程先调用 PATCH 接口更新 annotation 成功，资源的 ResourceVersion 为1，但紧接着马上发出了一个 PUT status 的接口，资源的 ResourceVersion 更新为2，此时的 annotation 为老版本的 annotation，导致 PATCH 接口的更新失效了。\n\n### 问题根因\n\nclient-go 的 UpdateStatus 接口本质为调用 APIServer 的 PUT `{resource}/status` 接口，按照[官方 API 文档](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status)的说法，Update 接口不会更新 status，所以额外提供了  PUT `{resource}/status` 接口。\n\n> The PUT and POST verbs on objects MUST ignore the \"status\" values, to avoid accidentally overwriting the status in read-modify-write scenarios. A `/status` subresource MUST be provided to enable system components to update statuses of resources they manage.\n\n查看 APIServer 代码的具体实现，\n\n[pkg/registry/core/pod/storage/storage.go](https://github.com/kubernetes/kubernetes/blob/release-1.20/pkg/registry/core/pod/storage/storage.go#L71) 为初始化 Pod 相关接口的 handler\n\n```go\nfunc NewStorage(optsGetter generic.RESTOptionsGetter, k client.ConnectionInfoGetter, proxyTransport http.RoundTripper, podDisruptionBudgetClient policyclient.PodDisruptionBudgetsGetter) (PodStorage, error) {\n\n\tstore := &genericregistry.Store{\n\t\tNewFunc:                  func() runtime.Object { return &api.Pod{} },\n\t\tNewListFunc:              func() runtime.Object { return &api.PodList{} },\n\t\tPredicateFunc:            registrypod.MatchPod,\n\t\tDefaultQualifiedResource: api.Resource(\"pods\"),\n\n\t\tCreateStrategy:      registrypod.Strategy,\n\t\tUpdateStrategy:      registrypod.Strategy,\n\t\tDeleteStrategy:      registrypod.Strategy,\n\t\tReturnDeletedObject: true,\n\n\t\tTableConvertor: printerstorage.TableConvertor{TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)},\n\t}\n\toptions := &generic.StoreOptions{\n\t\tRESTOptions: optsGetter,\n\t\tAttrFunc:    registrypod.GetAttrs,\n\t\tTriggerFunc: map[string]storage.IndexerFunc{\"spec.nodeName\": registrypod.NodeNameTriggerFunc},\n\t\tIndexers:    registrypod.Indexers(),\n\t}\n\tif err := store.CompleteWithOptions(options); err != nil {\n\t\treturn PodStorage{}, err\n\t}\n\n\tstatusStore := *store\n\tstatusStore.UpdateStrategy = registrypod.StatusStrategy\n\tephemeralContainersStore := *store\n\tephemeralContainersStore.UpdateStrategy = registrypod.EphemeralContainersStrategy\n\n\tbindingREST := &BindingREST{store: store}\n\treturn PodStorage{\n\t\tPod:                 &REST{store, proxyTransport},\n\t\tBinding:             &BindingREST{store: store},\n\t\tLegacyBinding:       &LegacyBindingREST{bindingREST},\n\t\tEviction:            newEvictionStorage(store, podDisruptionBudgetClient),\n\t\tStatus:              &StatusREST{store: &statusStore},\n\t\tEphemeralContainers: &EphemeralContainersREST{store: &ephemeralContainersStore},\n\t\tLog:                 &podrest.LogREST{Store: store, KubeletConn: k},\n\t\tProxy:               &podrest.ProxyREST{Store: store, ProxyTransport: proxyTransport},\n\t\tExec:                &podrest.ExecREST{Store: store, KubeletConn: k},\n\t\tAttach:              &podrest.AttachREST{Store: store, KubeletConn: k},\n\t\tPortForward:         &podrest.PortForwardREST{Store: store, KubeletConn: k},\n\t}, nil\n}\n```\n\n而 StatusUpdate 接口与普通 Update 接口的区别主要是 `statusStore.UpdateStrategy = registrypod.StatusStrategy` 。\n\n深入观察两种策略的不同，发现 Update 使用的 `registrypod.Strategy` 会使用老 Pod 的 Status。\n\n```go\n// PrepareForUpdate clears fields that are not allowed to be set by end users on update.\nfunc (podStrategy) PrepareForUpdate(ctx context.Context, obj, old runtime.Object) {\n\tnewPod := obj.(*api.Pod)\n\toldPod := old.(*api.Pod)\n\tnewPod.Status = oldPod.Status\n\n\tpodutil.DropDisabledPodFields(newPod, oldPod)\n}\n```\n\nStatusUpdate 接口使用的 `registrypod.StatusStrategy` 策略会使用老 Pod 的 Spec。\n\n```go\nfunc (podStatusStrategy) PrepareForUpdate(ctx context.Context, obj, old runtime.Object) {\n\tnewPod := obj.(*api.Pod)\n\toldPod := old.(*api.Pod)\n\tnewPod.Spec = oldPod.Spec\n\tnewPod.DeletionTimestamp = nil\n\n\t// don't allow the pods/status endpoint to touch owner references since old kubelets corrupt them in a way\n\t// that breaks garbage collection\n\tnewPod.OwnerReferences = oldPod.OwnerReferences\n}\n```\n\n而出问题的 annotation 即不属于 Spec，也不属于 Status，故两个操作会产生协程冲突。\n\n### 解决方案\n\n将 annotation 更新的 Pod 接口与 UpdateStatus 接口整合。\n\n","tags":["clint-go","APIServer"],"categories":["Kubernetes"]},{"title":"K8s 集群证书问题记录","url":"/2021/11/24/2021-11-24-k8s-certs/","content":"\n最近在环境中部署了一个 Virtual-Kubelet，由于它与 APIServer 的证书交互出了一些问题，导致了一些功能不可用，故去了解了下 K8s 集群的所有证书与关系，做一个梳理。\n<!--more-->\n\n### https 流程\n\n想了解证书的关系，首先要弄清楚 https 的流程，可以先阅读[这篇文章](https://segmentfault.com/a/1190000038406039)。\n\n简单来说，完成一次 https 连接，需要有以下证书密钥互相传输：\n\n- server 端公钥、证书\n- client 端公钥、证书\n\n### 问题现象\n\n用户使用 ServiceAccoutToken 分配的证书，无法访问 Virtual-Kubelet 上的 mtrics 接口，但是可以直接访问原生 Kubelet 的 metrics 接口。\n\n### 问题分析\n\n一开始感觉是 Virtual-Kubelet 起的 TLS 服务配置问题，故先进行‘拆盲盒’，参考原生 Kubelet 配置，将 Virtual-Kubelet server 的 TLS 支持版本、支持算法等配置都进行了修改，但是没有解决问题。\n\n后来找了环境部署相关的同事做了了解，由于安全原因，我们 K8s 集群使用两套证书配置，其中一套用于 APIServer 提供 server（称为CA1），一套用于访问 Kubelet 作为 client（称为CA2），这两套使用不同的 CA 证书签发，所以无法直接互相访问。\n\n在两套证书的背景下，会发现理论上使用 ServiceAccoutToken 也应该访问不到原生 Kubelet 的 metrics 接口，因为 ServiceAccoutToken 是由 APIServer 的 server ca 证书（即CA1）签发的，而访问 metrics 接口的网络路由是用户 client 访问 APIServer server，然后 APIServer client 访问 Kubelet metrics 接口，Kubelet server 证书理论上应该是使用 CA2 签发的，应该无法访问。\n\n### 问题根因\n\n通过走读原生 [Kubelet 代码](https://github.com/kubernetes/kubernetes/blob/e53cf077240c8febae2abe947cfefc1e6335057f/cmd/kubelet/app/server.go#L1094)，发现了根因。\n\n```go\n\tif len(kc.Authentication.X509.ClientCAFile) > 0 {\n\t\tclientCAs, err := certutil.NewPool(kc.Authentication.X509.ClientCAFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to load client CA file %s: %w\", kc.Authentication.X509.ClientCAFile, err)\n\t\t}\n\t\t// Specify allowed CAs for client certificates\n\t\ttlsOptions.Config.ClientCAs = clientCAs\n\t\t// Populate PeerCertificates in requests, but don't reject connections without verified certificates\n\t\ttlsOptions.Config.ClientAuth = tls.RequestClientCert\n\t}\n```\n\n\n\n原来 Kubelet Server 原生的配置对于 Client 证书的合法性并不做验证，只要提供了就可以访问。\n\n### 解决方案\n\n将 Virtual-Kubelet 的 ClientAuth 也 设置成 `tls.RequestClientCert`。\n\n### 参考文档\n\n[一文带你彻底厘清 Kubernetes 中的证书工作机制](https://mp.weixin.qq.com/s/IbxRTQBOeKtL8AlC3R65Rw)\n\n[https的认证加密过程](https://segmentfault.com/a/1190000038406039)\n\n","tags":["安全","tls","https","Virtual-Kubelet"],"categories":["Kubernetes"]},{"title":"如何看到 Pod 的失败原因","url":"/2021/11/22/2021-11-22-termination-message/","content":"\n在生产环境中，如果没有配置合适的告警，可能会发现某个 Pod 有 restartCount，但是由于已经重启了超过一小时，没有相关的 Events，导致无法看到响应的 Pod 重启原因。想要捕获每一次 Pod 退出异常，K8s 为我们提供了 Pod.spec.container[0].terminationMessagePath field ，来记录 Pod 异常退出时的信息。\n<!--more-->\n\n本文不对 terminationMessagePath 的具体配置以及用法做相关介绍，可参考[官方文档](https://kubernetes.io/docs/tasks/debug-application-cluster/determine-reason-pod-failure/)；本文会记录一些文档中没有提及但实际使用中会遇到的一些小 tips。\n\n### 如何在 Pod 重启一小时后查看 Pod 退出原因？\n\n通过 `kubectl describe pod` 可以看到 Pod 上次的退出状态\n\n```\n    Last State:     Terminated\n      Reason:       Error\n      Exit Code:    2\n      Started:      Wed, 17 Nov 2021 14:51:42 +0800\n      Finished:     Wed, 17 Nov 2021 14:51:42 +0800\n```\n\n其中 Exit Code 为程序退出的错误码，有一定参考含义，Reason 和 Last State 为 Pod 退出时在 K8s 集群中表现的状态。\n\n但以上信息对于判断 Pod 退出的真正原因是远远不够的。\n\n### 在 Pod 宿主机上获取 Pod 异常退出的日志\n\n先说结论，对于配置了 terminationMessagePath 和 terminationMessagePolicy 的 Pod，Kubelet 会添加一个对于用户不可见的 hostPath volume，用于将退出信息保存在宿主机上，该目录为`/var/log/pods/{pod-name}/{container-name}`，该目录下会记录 Pod 标准输出的日志，每个日志文件的前缀编号为 Pod 重启次数。根据该日志就能清晰的显示出 Pod 退出时的 log，从而判断异常原因。\n\n接下来我们可以看下 kubelet （v1.20.4）的源码，看看其内在的逻辑。\n\n```go\n// makeMounts generates container volume mounts for kubelet runtime v1.\nfunc (m *kubeGenericRuntimeManager) makeMounts(opts *kubecontainer.RunContainerOptions, container *v1.Container) []*runtimeapi.Mount {\n\tvolumeMounts := []*runtimeapi.Mount{}\n\n\tfor idx := range opts.Mounts {\n\t\tv := opts.Mounts[idx]\n\t\tselinuxRelabel := v.SELinuxRelabel && selinux.SELinuxEnabled()\n\t\tmount := &runtimeapi.Mount{\n\t\t\tHostPath:       v.HostPath,\n\t\t\tContainerPath:  v.ContainerPath,\n\t\t\tReadonly:       v.ReadOnly,\n\t\t\tSelinuxRelabel: selinuxRelabel,\n\t\t\tPropagation:    v.Propagation,\n\t\t}\n\n\t\tvolumeMounts = append(volumeMounts, mount)\n\t}\n\n\t// The reason we create and mount the log file in here (not in kubelet) is because\n\t// the file's location depends on the ID of the container, and we need to create and\n\t// mount the file before actually starting the container.\n\t// we can only mount individual files (e.g.: /etc/hosts, termination-log files) on Windows only if we're using Containerd.\n\tsupportsSingleFileMapping := m.SupportsSingleFileMapping()\n\tif opts.PodContainerDir != \"\" && len(container.TerminationMessagePath) != 0 && supportsSingleFileMapping {\n\t\t// Because the PodContainerDir contains pod uid and container name which is unique enough,\n\t\t// here we just add a random id to make the path unique for different instances\n\t\t// of the same container.\n\t\tcid := makeUID()\n\t\tcontainerLogPath := filepath.Join(opts.PodContainerDir, cid)\n\t\tfs, err := m.osInterface.Create(containerLogPath)\n\t\tif err != nil {\n\t\t\tutilruntime.HandleError(fmt.Errorf(\"error on creating termination-log file %q: %v\", containerLogPath, err))\n\t\t} else {\n\t\t\tfs.Close()\n\n\t\t\t// Chmod is needed because ioutil.WriteFile() ends up calling\n\t\t\t// open(2) to create the file, so the final mode used is \"mode &\n\t\t\t// ~umask\". But we want to make sure the specified mode is used\n\t\t\t// in the file no matter what the umask is.\n\t\t\tif err := m.osInterface.Chmod(containerLogPath, 0666); err != nil {\n\t\t\t\tutilruntime.HandleError(fmt.Errorf(\"unable to set termination-log file permissions %q: %v\", containerLogPath, err))\n\t\t\t}\n\n\t\t\t// Volume Mounts fail on Windows if it is not of the form C:/\n\t\t\tcontainerLogPath = volumeutil.MakeAbsolutePath(goruntime.GOOS, containerLogPath)\n\t\t\tterminationMessagePath := volumeutil.MakeAbsolutePath(goruntime.GOOS, container.TerminationMessagePath)\n\t\t\tselinuxRelabel := selinux.SELinuxEnabled()\n\t\t\tvolumeMounts = append(volumeMounts, &runtimeapi.Mount{\n\t\t\t\tHostPath:       containerLogPath,\n\t\t\t\tContainerPath:  terminationMessagePath,\n\t\t\t\tSelinuxRelabel: selinuxRelabel,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn volumeMounts\n}\n```\n\n`pkg/kubelet/kuberuntime/kuberuntime_container.go` 下可以看到，`if opts.PodContainerDir != \"\" && len(container.TerminationMessagePath) != 0 && supportsSingleFileMapping` 就会触发TerminationMessage 的挂载，hostPath 为 `containerLogPath = volumeutil.MakeAbsolutePath(goruntime.GOOS, containerLogPath)` 。\n\ncontainerLogPath 的路径为 `containerLogPath := filepath.Join(opts.PodContainerDir, cid)` ，`cid` 是一个随机的 UID。opts.PodContainerDir 的默认值为`/var/lib/kubelet/pods/{pod-uid}/containers/{container-name}` 。在宿主机该目录下，你同样可以看到 Pod 的所有输出，包括上述的退出日志，但是由于文件名是 uid，不是那么直观，只能通过时间来判断具体哪份日志。\n\n至于如何将 `/var/lib/kubelet/pods/{pod-uid}/containers/{container-name}` 的日志转换到 `/var/log/pods/{pod-name}/{container-name}` 下，简单看了下貌似是 CRI 做的，所以我猜测 不同的 CRI 可能有不同的表现，笔者的环境 CRI 为 containerd，这一块如有错误麻烦大家指正。","tags":["Pod","terminationMessagePath"],"categories":["Kubernetes"]},{"title":"Kubernetes 集群一致性测试工具 Sonobuoy 介绍","url":"/2021/06/23/2021-06-23-sonobuoy/","content":"\n[Sonobuoy](https://github.com/vmware-tanzu/sonobuoy) 是一种诊断工具，通过以可访问且无损的方式运行一组插件（包括Kubernetes一致性测试），可以更轻松地了解Kubernetes集群的状态。 这是一种可定制，可扩展且与群集无关的方式，可以生成有关群集的清晰，有用的报告。\n<!--more-->\n\n> Sonobuoy is a diagnostic tool that makes it easier to understand the state of a Kubernetes cluster by running a set of plugins (including [Kubernetes](https://github.com/kubernetes/kubernetes) conformance tests) in an accessible and non-destructive manner. It is a customizable, extendable, and cluster-agnostic way to generate clear, informative reports about your cluster.\n\n\n\n运行 Sonobuoy 后会在集群创建一个 sonobuoy/sonobuoy 的 pod 用于收集测试信息，并且会根据测试插件逻辑不停的启动测试 pod 进行测试，待全部测试 pod 运行完成后会生成测试报告。\n\n### 安装 sonobuoy\n\n1. [下载 sonobuoy](https://github.com/vmware-tanzu/sonobuoy/releases) 执行文件，版本与你 k8s 集群一致，比如要测试 1.19 的 k8s 集群，则下载 0.19 的sonobuoy release\n\n\n\n> Sonobuoy supports 3 Kubernetes minor versions: the current release and 2 minor versions before. Sonobuoy is currently versioned to track the Kubernetes minor version to clarify the support matrix. For example, Sonobuoy v0.14.x would support Kubernetes 1.14.x, 1.13.x, and 1.12.x.\n\n\n\n2. `tar -xvf <RELEASE_TARBALL_NAME>.tar.gz` 解压至执行目录。\n\n\n\n### 预置测试镜像（若节点可直接拉取镜像，可跳过）\n\n如果待测试集群有翻墙下载镜像条件，可忽略此步骤。提供下列两种方式预置镜像\n\n\n\n#### 手动预置镜像\n\n1. 使用 sonobuoy 命令获取测试使用的全量镜像列表\n\n```bash\nexport TEST_KUBECONFIG=~/.kube/config\n./sonobuoy --kubeconfig=${TEST_KUBECONFIG} images\n```\n\n1. 给待测试 k8s 集群每个 k8s-node 节点提前预置好镜像（以 conformance 镜像为例）\n\n```bash\n# 在可翻墙的节点执行以下命令，{{ k8s-node-ip }} 替换成待测试集群 k8s node 的IP\ndocker pull k8s.gcr.io/conformance:v1.19.3\ndocker save k8s.gcr.io/conformance:v1.19.3 -o ./conformance:v1.19.3\nscp ./conformance:v1.19.3 root@{{ k8s-node-ip }}:/tmp/\n\n# ssh 到每一个 k8s node，执行以下命令加载镜像\n# ctr 在 k8s 集群中需要指定 namespace（如果是 docker 可以改成 docker load 命令）\nctr -n k8s.io image import /tmp/conformance\\:v1.19.3\n```\n\n\n\n#### 脚本自动化预置镜像\n\n1. 在可翻墙节点执行以下脚本。\n\n```bash\nvi downloadSonobuoyImages.sh\nchmod +x downloadSonobuoyImages.sh\n\n# /Users/cbs/test 是 sonobuoy 二进制文件所在目录的上级目录，sonobuoy 目录为 /Users/cbs/test/sonobuoy\n# /Users/cbs/.kube/config 是待测试集群 kubeconfig 文件路径\n# /tmp/sonobuoy 是产生镜像 tar.gz 存储目录，需要提前 mkdir\n./downloadSonobuoyImages.sh /Users/cbs/test /Users/cbs/.kube/config /tmp/sonobuoy\n\ncd /tmp/sonobuoy\nscp sonobuoyimages.tar.gz root@{{ k8s-node-ip }}:/tmp/\n```\n\ndownloadSonobuoyImages.sh 脚本参考如下：\n\n```bash\n#!/bin/bash\nset -o nounset\n\n# 该脚本会下载所有 sonobuoy 运行所需所有镜像并在脚本执行路径打包成sonobuoyimages.tar.gz\n# sonobuoy 二进制文件所在目录的上级目录，如 sonobuoy 的目录为 /Users/cbs/test/sonobuoy，这个参数应该输入 /Users/cbs/test.\nsonobuoy_path=$1\n# 待测试集群kubeconfig文件路径，需要根据测试集群版本获取全量镜像列表\nkubeconfig_path=$2\n# 输出镜像文件地址，需要提前mkdir\noutput_path=$3\n\nexport PATH=$PATH:$sonobuoy_path\n\nimage_count=1\nfor image in `sonobuoy --kubeconfig=$kubeconfig_path images`\n{\n  docker pull ${image}\n  docker save ${image} -o ${output_path}/${image_count}.tar.gz\n  docker rmi ${image}\n  image_count=`expr ${image_count} + 1`\n}\n\ncd ${output_path}\ntar -zcvf sonobuoyimages.tar.gz *.tar.gz\n```\n\n\n\n1. ssh 到每一个 k8s node，执行以下命令加载全量镜像。\n\n```bash\nvi loadSonobuoyImages.sh\nchmod +x loadSonobuoyImages.sh\n# /tmp/sonobuoyimages.tar.gz 是 sonobuoy 镜像压缩包地址\n# /tmp/sonobuoy 是解压 sonobuoyimages.tar.gz 产生镜像的中间目录，需要提前 mkdir\n./loadSonobuoyImages.sh /tmp/sonobuoyimages.tar.gz /tmp/sonobuoy\n```\n\nloadSonobuoyImages.sh 脚本代码参考如下：\n\n```bash\n# 将打包的 sonobuoy 镜像通过 ctr （或者 docker）加载到节点上\n# sonobuoy 镜像压缩包地址.\nsonobuoytar_path=$1\n# 输出镜像文件地址，需要提前 mkdir，并且该目录下没有其他 tar.gz 文件\noutput_path=$2\n\ntar Pxvfz $sonobuoytar_path -C ${output_path}/\ncd ${output_path}\nfor image in $(ls | grep tar.gz)\n{\n  ctr -n k8s.io image import $image\n}\n\n# ctr -n k8s.io i tag docker.io/sonobuoy/sonobuoy:v0.19.0  sonobuoy/sonobuoy:v0.19.0\n# ctr -n k8s.io i tag docker.io/sonobuoy/systemd-logs:v0.3  sonobuoy/systemd-logs:v0.3\n```\n\n#### 修改集群拉取镜像配置\n\n登录每个master节点，修改 kube-apiserver 的启动命令，删除启动命令中的 AlwaysPullImages ，等待apiserver重启。\n\n```bash\nvi /etc/kubernetes/manifests/kube-apiserver.yaml\n\nspec:\n  containers:\n  - command:\n    - kube-apiserver\n\n    ...\n\n    - --enable-admission-plugins=NodeRestriction,DenyEscalatingExec,AlwaysPullImages,EventRateLimit,PodSecurityPolicy\n\n    ...\n```\n\n\n\n### 运行 sonobuoy\n\n等待测试完成  时间会比较久，默认超时时间为3h。\n\n```bash\nexport TEST_KUBECONFIG=~/.kube/config\n./sonobuoy --kubeconfig=${TEST_KUBECONFIG} --image-pull-policy=IfNotPresent  run  --wait\n\n# 运行过程中，可以在其他终端执行以下命令查看运行状态\n\n./sonobuoy  --kubeconfig=${TEST_KUBECONFIG} status\n```\n\n### 查看测试结果\n\n```bash\nresults=$(./sonobuoy  --kubeconfig=${TEST_KUBECONFIG} retrieve)\n./sonobuoy results $results\n\n---output\nPlugin: e2e\nStatus: failed\nTotal: 5233\nPassed: 283\nFailed: 20\nSkipped: 4930\n\nFailed tests:\n\n[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]\n[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]\n[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]\n[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]\n[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]\n[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [NodeConformance] [Conformance]\n[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]\n[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]\n[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]\n[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]\n[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]\n[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]\n[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]\n[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]\n[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]\n[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]\n[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]\n[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]\n[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]\n[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]\n\nPlugin: systemd-logs\nStatus: passed\nTotal: 5\nPassed: 5\nFailed: 0\nSkipped: 0\n```\n\nPS：如果`sonobuoy retrieve`报错`error retrieving results: error: tmp/sonobuoy no such file or directory`，则代表测试结果因为某些原因丢失了，可以重新跑一次生成新结果再查看。\n\nPS：如果超时可以尝试`kubectl --kubeconfig=${TEST_KUBECONFIG} get csr | grep Pending | awk '{print $1}' | xargs -I {} kubectl --kubeconfig=${TEST_KUBECONFIG} certificate approve {}`\n\n### 调试失败用例\n\n#### sonobuoy results 查看详细日志\n\n[results 相关命令参考](https://sonobuoy.io/docs/v0.19.0/results/)，需要提前安装 jq（`brew install jq`）\n\n```bash\n./sonobuoy results $results --mode=detailed | jq 'select(.status==\"failed\")'\n```\n\n或者直接查看 detailed 日志文件\n\n```bash\n./sonobuoy results $results --mode=detailed > /tmp/sonobuoy.log\ncat /tmp/sonobuoy.log | grep \"\\\"status\\\":\\\"failed\\\"\"\n```\n\n#### 直接查看生成日志\n\n1. 可以直接解压日志文件查看详细信息，执行`./sonobuoy  --kubeconfig=${TEST_KUBECONFIG} retrieve`后会在当前文件生成`{{ data }}_sonobuoy_{{ UUID }}.tar.gz`文件（可以通过`echo $results`查看文件名称）。\n2. 解压该文件后查看`/podlogs/<namespace>/<podname>/logs/<plugin-name>.txt`日志可获取具体用例失败信息，[文件详细目录参考](https://sonobuoy.io/docs/v0.19.0/snapshot/)。\n3. 若相关日志无法明确错误信息，需要查看对应用例代码寻找根因，定位过程参考 [sonobuoy/issues/1151](https://github.com/vmware-tanzu/sonobuoy/issues/1151)。\n\n\n\n### 清理 sonobuoy\n\n该步骤会删除 sonobuoy 测试过程中生成的 k8s 资源，如果用例执行失败，会有插件 pod 残留，需要手动删除。\n\n```bash\n./sonobuoy --kubeconfig=${TEST_KUBECONFIG} delete --wait\n```","tags":["集群一致性","e2e test"],"categories":["Kubernetes"]},{"title":"摆脱第三方库系列（三）- 自己写顶部滚动标签栏","url":"/2021/03/05/2016-04-30-segmentview/","content":"\n\n# 前言\n\n*好久没写博客了，最近自己参考了一些源码写了一个标签页，并把他传到了CocoaPods上。大家可以集成到项目中进行使用，也可以看看源码自己写一个更好的，也希望如果有什么意见可以告诉我，我会进行完善。*\n<!--more-->\n\n# 成果\n\n自己写了两种形式的Demo，一种类似网易云音乐的固定的标签栏，一种是类似爱奇艺、今日头条的可滚动的标签栏。一开始只是草草的写，后来经过师傅提醒考虑了下优化，只有移动到那个页面才会对ViewController进行加载，这样即使是很复杂的页面很多网络请求数据加载应该也不会有卡顿的现象。\n\n![wait](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/iOS/segment1.gif)\n\n![wait](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/iOS/segment2.gif)\n\n如果有想加入项目中使用的同学可以利用CocoaPods，具体使用我放在[github](https://github.com/cbsfly/CBSSegmentView)上了，欢迎使用。也可以把github上的zip直接下载下来看使用方法。接下来简单介绍下实现原理。\n\n# 实现原理\n\n简单的说，顶部的标签栏是UIScrollView，底下也是一个UIScrollView，将多个`ViewController.view`初始化加入到下面ScrollView中的合适位置，并且与顶部的标签栏相关联，并且给上面的标签栏增加点击事件控制下部分的ScrollView可以移动到合适的位置就行了！\n\n# 部分源码解析\n\n感觉其实没什么难点，比较需要动脑筋的实现应该就是顶部标签栏随下面ScrollView的滑动，包括字体颜色，下划线移动。我就对这一部分进行介绍，对其他地方感兴趣的同学可以自己把源码下载下来看看。\n\n这里先上代码，先上顶部标签栏的初始化方法。这一部分比较繁琐，肯定可以简化代码，时间有点紧就没做了。\n\n\t- (void)addScrollHeader:(NSArray *)titleArray\n\t{\n\t    self.headerView.frame = CGRectMake(0, 0, self.width, self.buttonHeight);\n\t    self.headerView.contentSize = CGSizeMake(self.buttonWidth*titleArray.count, self.buttonHeight);\n\t    [self addSubview:self.headerView];\n    \n\t    for (NSInteger index = 0; index < titleArray.count; index++) {\n\t        _titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(self.buttonWidth*index, 0, self.buttonWidth, self.buttonHeight)];\n\t        _titleLabel.textColor = [UIColor blackColor];\n\t        _titleLabel.text = titleArray[index];\n\t        _titleLabel.textAlignment = NSTextAlignmentCenter;\n\t        _titleLabel.adjustsFontSizeToFitWidth = YES;\n\t        [self.headerView addSubview:_titleLabel];\n        \n\t        _segmentBtn = [[UIButton alloc] initWithFrame:CGRectMake(self.buttonWidth*index, 0, self.buttonWidth, self.buttonHeight)];\n\t        _segmentBtn.tag = index;\n\t        [_segmentBtn setBackgroundColor:[UIColor clearColor]];\n\t        [_segmentBtn addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchUpInside];\n\t        [self.headerView addSubview:_segmentBtn];\n\t    }\n    \n    \n\t    self.headerSelectedSuperView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, self.buttonWidth, self.buttonHeight)];\n\t    [self.headerView addSubview:self.headerSelectedSuperView];\n    \n\t    self.headerSelectedView.frame =CGRectMake(0, 0, self.buttonWidth, self.buttonHeight);\n\t    self.headerSelectedView.contentSize = CGSizeMake(self.buttonWidth*titleArray.count, self.buttonHeight);\n\t    [self.headerSelectedSuperView addSubview:self.headerSelectedView];\n\n\t    for (NSInteger index = 0; index < titleArray.count; index++) {\n\t        _titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(self.buttonWidth*index, 0, self.buttonWidth, self.buttonHeight)];\n\t        _titleLabel.textColor = [UIColor blueColor];\n\t        _titleLabel.text = titleArray[index];\n\t        _titleLabel.textAlignment = NSTextAlignmentCenter;\n\t        _titleLabel.adjustsFontSizeToFitWidth = YES;\n\t        [self.headerSelectedView addSubview:_titleLabel];\n        \n\t    }\n\n\t    UIImageView *bottomLine = [[UIImageView alloc] initWithFrame:CGRectMake(0, self.headerSelectedView.contentSize.height - self.lineHeight, self.headerSelectedView.contentSize.width, self.lineHeight)];\n\t    bottomLine.backgroundColor = [UIColor blueColor];\n\t    [self.headerSelectedView addSubview:bottomLine];\n\t}\n\t\n这里的实现主要分成三个步骤，一开始在顶部加上一个`self.headerView`，这是一个UIScrollView，他是标签栏视图的最底层，所以需要最先add上去。在`self.headerView`我们会加上若干个UILabel，这几个UILabel就是没选中时的标签样子，就是上文gif中黑色的标签。然后再加上若干个透明的Button方便添加点击事件，当然也可以用手势这里随意。\n\n第二步就是加一个UIView的“父视图”`self.headerSelectedSuperView`,这个父视图的作用稍后说。\n\n第三步就是再加上一个UIScrollView`self.headerSelectedView`,这是当前选中标签应该展现的外观的ScrollView，我们在这个ScrollView里加入若干个UILabel，不同的是颜色要设置成选中标签后的颜色，这里我设置的是蓝色。为了美观，还加了一个蓝色的下划线。第三步有个关健就是将`        _headerSelectedView.clipsToBounds = YES;`这个代码我在headerSelectedView的get方法里面写了。这个属性是说子视图如果比父视图大，则将超出的部分去掉，默认是NO的。不是很理解的最好取谷歌下，这个属性是实现上图效果的关健。\n\n然后看UIScrollView的代理方法。\n\n\t- (void)scrollViewDidScroll:(UIScrollView *)scrollView\n\t{\n\t    if (scrollView == _backView) {\n\t        self.headerSelectedSuperView.frame = CGRectMake(scrollView.contentOffset.x * (self.buttonWidth/self.width), self.headerSelectedSuperView.frame.origin.y, self.headerSelectedSuperView.frame.size.width, self.headerSelectedSuperView.frame.size.height);\n\t        self.headerSelectedView.contentOffset = CGPointMake(scrollView.contentOffset.x * (self.buttonWidth/self.width), 0);\n\t    }\n\t}\n\t\nbackView就是下面ViewController存放的ScrollView，当backView滚动时，我们需要改变标签栏headerSelectedSuperView的frame和headerSelectedView的contentOffset，这样的结果就是headerSelectedSuperView能移动到合适的位置，并且展示出headerSelectedSuperView子视图也就是headerSelectedView合适的部分。这样就能有gif中标签栏的那种滚动效果了。这里就和`        _headerSelectedView.clipsToBounds = YES;`息息相关了。代码很简单。\n\n至于其他部分我就不一一解析了，还是推荐大家看看源码，也希望有什么意见可以告诉我，互相提高互相进步。","categories":["iOS"]},{"title":"用AFNetworking3.0封装网络请求","url":"/2021/03/05/2016-01-15-network/","content":"# 前言\n\n由于之前一直是用别人封装好的网络请求，一来版本太旧，二来觉得太臃肿很多功能代码不知道是干嘛的，所以想尝试自己封装一个网络请求，可能比较简单比较入门，很多问题肯定考虑不周，而且网上关于AFNetworking3.0库的教程也不多，所以大家当成3.0的小教程就好。\n<!--more-->\n\n# 配置AFNetworking环境\n\n[AFNetworking](https://github.com/AFNetworking/AFNetworking)更新了3.0，之前的工程一直用的2.63。这两个版本变化还是比较大的，以前的AFNetworking是NSURLConnection + NSOperation，但是**3.0版本移除了对NSURLConnectionOperation的支持**，这意味着之前版本的“主力军”被移除了，所以若是原封不动的用之前工程网络请求部分的代码一般都会报错，所以大家都要尝试用新版的AFNetworking来更新自己的网络请求了。取消了NSURLConnectionOperation，AFNetworking是用iOS7中新的网络接口NSURLSessionOperation来代替的。NSURLSessionOperation在程序进入后台后会比NSURLConnectionOperation更加灵活，更先进。\n\n为了使用AFNetworking3.0，还有一个比较坑爹的是你必须使用Xcode7以上的版本。因为AFNetworking3.0 使用了`nullable`新特性，而低版本的Xcode并不识别，所以用低版本的Xcode运行3.0会报错。更坑爹的是要用Xcode7还要更新你OS X到EI Capitan版本，光更新这两个我就花了一天的时间（其实笔者下载了两次Xcode7才发现要先更新操作系统才行）。更新操作系统踩坑点[这里](http://www.jianshu.com/p/15deb543bb52)。\n\n有了Xcode7，就可以用cococapods下载配置最新的AFNetworking了。\n\n\tplatform :ios, '8.0'\n\tpod 'AFNetworking', '~> 3.0'\n\t\n坑爹的事还有，在iOS 9中 苹果将原http协议改成了https协议 使用 TLS1.2 SSL加密请求数据，所以我们不能直接请求http协议下的数据了。\n\n解决办法也很简单，用编辑器打开工程文件下的Info.plist文件添加下面的代码就可以了\n\n\t<key>NSAppTransportSecurity</key>  \n    \t<dict>  \n          <key>NSAllowsArbitraryLoads</key><true/>  \n    \t</dict>  \n    \t\nstackoverflow的回答点[这里](http://stackoverflow.com/questions/31254725/transport-security-has-blocked-a-cleartext-http)。\n\n这样一来我们就配置好环境了。\n\n# 使用AFNetworking\n很多人对AFNetworking都不陌生，这一段可能有点老生常谈的感觉。\n\n用AFNetworking第一步都是一样的，即创建一个manager。关于self-manager的扩展可以看[这篇文章](http://blog.sunnyxx.com/2015/12/19/self-manager-pattern-in-ios/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)学习一下。\n\n在AFNetworking中创建manager的方法是这样的\n\n    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];\n\n在AppDelegate中你需要开启你的网络监听器，这样AFStringFromNetworkReachabilityStatus属性就有了值显示你的网络状态。\n\n    [[AFNetworkReachabilityManager sharedManager] startMonitoring];\n\n如果你需要上传或者下载数据，那么还需要创建一个NSURLSessionConfiguration类，本文只讲述普通的请求数据，所以先不涉及NSURLSessionConfiguration。\n\n请求数据大部分情况下就是像服务器发送GET或者POST请求，然后服务器会返回你一串JSON格式的数据，你需要解析这段JSON数据然后呈现在你的UI上。\n\n>GET - 从指定的资源请求数据。\n>\n>POST - 向指定的资源提交要被处理的数据\n\t\nAFNetworking请求数据的代码也很简单。\n\n\t[manager GET:@\"http://httpbin.org/get\" parameters:nil progress:nil success:^(NSURLSessionTask *task, id responseObject) {\n        NSLog(@\"JSON: %@\", responseObject);\n    } failure:^(NSURLSessionTask *operation, NSError *error) {\n        NSLog(@\"Error: %@\", error);\n    }];\n    \n这段代码非常易懂，这也是AFNetworking的强大之处。`parameters:`后面跟着的是你需要给后台传送的参数。而`id responseObject`是后台返给你的数据。我输出了一下`[responseObject class]`发现responseObject是一个NSDictionary，那么以后在字典中用的方法也适用于responseObject，后面的代码中我也做了修改。\n\n这样我们就成功请求到了数据。接下来要做的就是封装了。\n\n# 网络请求的封装\n记得学习软件工程的时候我们老师给我们反复强调了代码复用的重要性，我当时也深受启发。而网络请求在我们的应用开发中我觉得是最常用的需要代码复用的部分，因为他使用次数多，且代码都差不多，不受别的模块代码干扰，即低耦合,高内聚。\n\n上文提到了我们进行网络请求要先创建一个manager，就是说每次请求我们都需要创建manager。那么我们先对这一步进行封装。\n\n先创建一个新的继承于AFHTTPSessionManager的类，我这里就叫cbsNetWork了。在我的封装中，一开始我是先创建一个类方法。\n\n\t+ (instancetype)sharedManager {\n    static cbsNetWork *manager = nil;\n    static dispatch_once_t pred;\n    dispatch_once(&pred, ^{\n        manager = [[self alloc] initWithBaseURL:[NSURL URLWithString:@\"http://httpbin.org/\"]];\n    });\n    return manager;\n\t}\n\n这是每次执行网络请求库的时候都要执行的方法。在这个方法中，其实就是初始化了一个manager，但与一般的创建不同，这里用到了`dispatch_once`也就是iOS ARC中创建单例模式的方法。为何这里要用到单例模式？因为这个manager应该是系统中唯一的实例。而`dispatch_once`中的方法不管多少次调用都只会运行一次。更多的关于单例模式点[这个网站](http://www.jianshu.com/p/7486ebfcd93b)吧。\n\n接下来就是重写父类的初始化方法`initWithBaseURL`。在父类(也就是AFNetworking)中`initWithBaseURL`只是拼接了基URL和后来的路径，并且规定了默认的请求序列和响应序列。而在我们的实际工程中肯定需要更多的属性设置，例如延时要求，缓存要求等。这里的属性设置具体原因不用细究，只要知道这个方法的作用就好。\n\n\t-(instancetype)initWithBaseURL:(NSURL *)url\n\t{\n    self = [super initWithBaseURL:url];\n    if (self) {\n        // 请求超时设定\n        self.requestSerializer.timeoutInterval = 5;\n        self.requestSerializer.cachePolicy = NSURLRequestReloadIgnoringLocalCacheData;\n        [self.requestSerializer setValue:@\"application/json\" forHTTPHeaderField:@\"Accept\"];\n        [self.requestSerializer setValue:url.absoluteString forHTTPHeaderField:@\"Referer\"];\n        \n        self.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@\"application/json\", @\"text/plain\", @\"text/javascript\", @\"text/json\", @\"text/html\", nil];\n        \n        self.securityPolicy.allowInvalidCertificates = YES;\n    }\n    return self;\n\t}\n\n然后就是封装AFNetworking的部分了。这里我只是封装了一个请求数据的方法，比较简单，当然不能下载和上传，以后我会完善。\n\n首先我们要在文件头定义两个block，在请求中我们需要用block回调数据来使用，因为AFNetworking请求数据方法中success块是没有返回值的，所以我们需要自己声明块来回调请求到的json数据再进行解析。\n\n块定义如下\n\n\t//请求成功回调block\n\ttypedef void (^requestSuccessBlock)(NSDictionary *dic);\n\n\t//请求失败回调block\n\ttypedef void (^requestFailureBlock)(NSError *error);\n\t\n为了分辨方法，我也定了也一个HTTP方法类来封装方法。\n\n\t//请求方法define\n\ttypedef enum {\n    GET,\n    POST,\n    PUT,\n    DELETE,\n    HEAD\n\t} HTTPMethod;\n\t\n接下来就是方法封装了\n\n\t- (void)requestWithMethod:(HTTPMethod)method\n                 WithPath:(NSString *)path\n               WithParams:(NSDictionary*)params\n         WithSuccessBlock:(requestSuccessBlock)success\n          WithFailurBlock:(requestFailureBlock)failure\n\t{\n    switch (method) {\n        case GET:{\n       \t     [self GET:path parameters:params progress:nil success:^(NSURLSessionTask *task, NSDictionary * responseObject) {\n         \t       NSLog(@\"JSON: %@\", responseObject);\n         \t       success(responseObject);\n       \t     } failure:^(NSURLSessionTask *operation, NSError *error) {\n         \t       NSLog(@\"Error: %@\", error);\n         \t       failure(error);\n        \t    }];\n        \t    break;\n     \t   }\n        case POST:{\n           \t [self POST:path parameters:params progress:nil success:^(NSURLSessionTask *task, NSDictionary * responseObject) {\n              \t  NSLog(@\"JSON: %@\", responseObject);\n         \t       success(responseObject);\n        \t    } failure:^(NSURLSessionTask *operation, NSError *error) {\n            \t    NSLog(@\"Error: %@\", error);\n            \t    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@\"提示\" message:error.localizedDescription delegate:nil cancelButtonTitle:@\"确定\" otherButtonTitles:nil, nil];\n             \t   [alert show];\n            \t    failure(error);\n            \t}];\n            \tbreak;\n        \t}\n        default:\n            break;\n    \t}    \n\t}\n\t\n我只是简单的封装了GET和POST两个方法，成功会讲请求到的json数据存储到一个字典responseObject中，然后通过回调方法在页面中使用，失败的话则回调了`NSError *error`。\n\n在ViewController中，我们即可用一个方法完成网络请求。\n\n\t[[cbsNetWork sharedManager] requestWithMethod:GET WithPath:@\"get\" WithParams:nil WithSuccessBlock:^(NSDictionary *dic) {\n        Model *model = [MTLJSONAdapter modelOfClass:[Model class] fromJSONDictionary:dic error:nil];\n        NSLog(@\"%@\", model.origin);\n    } WithFailurBlock:^(NSError *error) {\n        \n    }];\n    \n*PS：我的model是用Mantle解析的，所以想复制代码的同学自己用自己的办法写model吧，这不是重点。*\n\n这样简单的网络请求就封装好了，当然还可以更加完善可以再加一层专门写model解析数据这样你的ViewController代码会更简洁。\n\n这篇文章写的代码我会传到我的github上，有需要的可以[点开来](https://github.com/cbsfly/cbsNetWork)下载看。\n\n学艺不精，有错误的地方还请指出，我将万分感谢。","categories":["iOS"]},{"title":"摆脱第三方库系列（一）- 自己写一个侧拉菜单","url":"/2021/03/05/2016-02-23-slipview/","content":"\n# 前言\n\n一直有这么一个想法，就是摆脱第三方库来开发程序，虽然很不现实，但想尝试做一点努力。这篇文章先实现比较常见的侧拉菜单功能。\n<!--more-->\n\n# 侧拉菜单基本结构\n\n一般侧拉菜单就是一个中心页和一个侧边页构成。通过添加手势移动中心页，展示出侧边页。\n\n现在APP中常见的侧拉菜单大体可以分成两种类型的，一种是外国的APP（比如Steam，facebook）比较喜欢的分页式的侧拉菜单，就是用中心页覆盖住侧边页，然后移动中心页的时候就能展现出被中心页覆盖的侧边页；还有一种就是国内（比如知乎日报）比较喜欢的一体式侧拉菜单，侧边页放置在中心页的左边或者右边，拉动时就可展现另一页内容。下面两张图第一张是分页式，第二张是一体式。\n\n![wait](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/iOS/celapage.gif)\n\n![wait](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/iOS/celatogether.gif)\n\n# 实现侧拉菜单\n\n这篇文章将主要介绍一体式侧拉菜单的写法。\n\n先创建一个侧边页TogetherLeftView，最简单的继承于UIView的普通页面就行。在里面重写了初始化方法，改个颜色便于区分。\n\n\t- (instancetype)initWithFrame:(CGRect)frame\n\t{\n    \tself = [super initWithFrame:frame];\n   \t\tif (self) {\n    \t    self.backgroundColor = [UIColor redColor];\n    \t}\n    \treturn self;\n\t}\n\t\n然后就是中心页TogetherMainView，一般将手势写在这一页。先声明两个对象两个变量。还有宏定义侧边页的宽度\n\n\t#define LEFTVIEWWIDTH 280\n\t\n\t@interface TogetherMainView : UIView\n\t@property (nonatomic, assign) float centerX;\n\t@property (nonatomic, assign) float centerY;\n\t@property (nonatomic, strong) UIPanGestureRecognizer *panGestureRecognizer;\n\t@property (nonatomic, strong) UIButton *leftBtn;\n\t\n其中UIPanGestureRecognizer是苹果公司给的基本手势抽象类中的拖动手势，View添加这个后就可以拖动了。想学习其他基本手势的可以看看苹果UIGestureRecognizer的文档，这里不做介绍。leftBtn是点击后可以隐藏（出现）菜单的按钮。\n\n然后重写初始化方法。\n\n\t- (instancetype)initWithFrame:(CGRect)frame\n\t{\n    \tself = [super initWithFrame:frame];\n    \tif (self) {\n        \tCGRect screen = [[UIScreen mainScreen] bounds];\n        \tself.centerX = screen.size.width / 2;\n        \tself.centerY = screen.size.height / 2;\n        \n        \tself.backgroundColor = [UIColor greenColor];\n        \n        \t[self addSubview:self.leftBtn];\n        \t[self addGestureRecognizer:self.panGestureRecognizer];\n    \t}\n    \treturn self;\n\t}\n\n这里的centerX和centerY是对屏幕初始中心位置的记录，我们一会还原位置要用到。然后先看手势部分，panGestureRecognizer的get方法如下\n\n\t- (UIPanGestureRecognizer *)panGestureRecognizer\n\t{\n\t    if (_panGestureRecognizer == nil) {\n\t        _panGestureRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePan:)];\n\t    }\n\t    return _panGestureRecognizer;\n\t}\n\t\n这里给拖动时添加了一个方法handlePan，关键点就在这个方法里\n\n\t- (void)handlePan:(UIPanGestureRecognizer *)recognizer\n\t{\n\t    CGPoint translation = [recognizer \ttranslationInView:self];\n\t    float x = self.center.x + translation.x;\n\t    \n\t    if (x < _centerX) {\n\t        x = _centerX;\n\t    }\n\t    self.center = CGPointMake(x, _centerY);\n\t    \n\t    if (recognizer.state == UIGestureRecognizerStateEnded) {\n\t        [UIView animateWithDuration:0.2 animations:^(void){\n\t            if (x > (self.centerX + LEFTVIEWWIDTH/2)) {\n\t                self.center = CGPointMake(self.centerX + LEFTVIEWWIDTH, _centerY);\n\t            }else{\n\t                self.center = CGPointMake(_centerX, _centerY);\n\t            }\n\t        }];\n\t    }\n\t    [recognizer setTranslation:CGPointZero inView:self];\n\t}\n\t\n当我们在View界面中拖动时就会进入这个方法，我们先设一个CGPoint来获取每次得到的移动距离translation，然后`float x`就表示当前屏幕中心点的位置（原来的位置加上移动量）。\n\n由于我写的是一个左侧的菜单，所以中心页应该是不能左移的，假如我们左移，就会造成`x < _centerX`，那样的话旧把x设成原来的中心点centerX就行了，这样就能阻止中心页左移。（如果想阻止右移把小于改成大于就行了。\n\n然后就是在拖动效果结束（松开鼠标）时做一个判定，这里为了看起来平滑一点用了一个动画效果，如果拖动距离超过侧边页的一半旧显示出侧边页，否则还原。\n\n最后还要将recognizer置位零。因为拖动时会多次执行这个方法，如果不置零可能出错。\n\n这样最关键的部分就讲解完了，然后上按钮的动作代码，应该可以看的懂。\n\n\t- (UIButton *)leftBtn\n\t{\n\t    if (_leftBtn == nil) {\n\t        _leftBtn = [[UIButton alloc] initWithFrame:CGRectMake(20, 20, 120, 40)];\n\t        [_leftBtn setTitle:@\"点我弹出菜单\" forState:UIControlStateNormal];\n\t        [_leftBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];\n\t        [_leftBtn addTarget:self action:@selector(leftViewAppear) forControlEvents:UIControlEventTouchUpInside];\n\t    }\n\t    return _leftBtn;\n\t}\n\t\n\t- (void)leftViewAppear\n\t{\n\t    [UIView animateWithDuration:0.2 animations:^(void){\n\t        if (self.center.x == self.centerX) {\n\t            self.center = CGPointMake(self.centerX + LEFTVIEWWIDTH, self.centerY);\n\t        }else if (self.center.x == self.centerX + LEFTVIEWWIDTH) {\n\t            self.center = CGPointMake(self.centerX, self.centerY);\n\t        }\n\t    }];\n    \n\t}\n\t\n接下来就是添加到ViewController里面了，两个页面对象都要声明\n\n\t@property (nonatomic, strong) TogetherLeftView *leftView;\n\t@property (nonatomic, strong) TogetherMainView *mainView;\n\t\n这里上一下代码，不做过多解释\n\n\t- (void)viewDidLoad {\n\t    [super viewDidLoad];\n\t    [self.view addSubview:self.mainView];\n\t    [self.mainView addSubview:self.leftView];\n\t}\n\t\n\t- (TogetherMainView *)mainView\n\t{\n\t    if (_mainView == nil) {\n\t        _mainView = [[TogetherMainView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];\n\t    }\n\t    return _mainView;\n\t}\n\n\t- (TogetherLeftView *)leftView\n\t{\n\t    if (_leftView == nil) {\n\t        _leftView = [[TogetherLeftView alloc] initWithFrame:CGRectMake(-LEFTVIEWWIDTH, 0, LEFTVIEWWIDTH, [UIScreen mainScreen].bounds.size.height)];\n\t    }\n\t    return _leftView;\n\t}\n\t\n那么如何写一个分页式的侧拉菜单呢？其实主要的区别就是在ViewController中添加页面的时候用中心页将侧边页覆盖就行了，具体的代码可以去我的[github](https://github.com/cbsfly/cbsSlipView)下载来看。\n\n# 总结\n\n我想将比较常用的功能都自己动手写一遍这样更能明白底层的原理，我觉得更适合新手的学习，直接用第三方库谁都会，但哪天有需求变动要求你改你却无从下手就很尴尬了。这个系列我也会坚持下去，同样如果笔者哪里有错的地方希望大家提出来我好改正。\t","categories":["iOS"]},{"title":"利用RAC一句话实现上拉刷新下拉刷新","url":"/2021/03/05/2016-01-21-rac-refresh/","content":"\n最近在研究上拉刷新下拉刷新，有点小心得和大家分享下。\n\n首先我是先在网上搜博客看，发现要不就是用原生UIRefreshControl要不就是第三方库的教程，这都不是我想要的（好的开源库推荐[MJRefresh](https://github.com/CoderMJLee/MJRefresh)）。\n\n于是我开始看大神们的源代码，了解了下原理。\n<!--more-->\n\n# 刷新原理\n\n首先上拉下拉刷新肯定是基于UIScrollView的基础上的，包括UITableView其实也是一个UIScrollView。而实现上拉下拉刷新的原理就是UIScrollView中的代理方法\n\t\n\t- (void)scrollViewDidScroll:(UIScrollView *)scrollView;// any offset changes\n\n这个方法是在你的scrollView滚动时就会执行的方法。\n\n这里有必要说明下scrollView的两个属性，一个是contentSize，一个是contentOffset。这里上图片讲解可能直观一点。\n\n![挂了？！](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/iOS/scrollview.png)\n\n*PS：不会用mac的画图工具比较丑见谅。*\n\n看图，这里的绿色框就是我们的手机屏幕，我们的UI都是呈现在手机屏幕上的，那么黑色的框就是contentSize。就是说，虽然手机屏幕只有一点大，但是我们的scrollView并不是只有一点大的，这个属性是可以设置的，而我们滚动scrollView其实就是滚动黑色框，这样看到的界面就会不一样了。而图上标注的红点就是contentOffset。contentOffset是一个CGPoint，代表当前屏幕所在位置左上角相对于scrollView.contentSize左上角的横纵坐标值。\n\n了解了scrollView我们就来说刷新。在\n`- (void)scrollViewDidScroll:(UIScrollView *)scrollView;// any offset changes`方法中我们应该监听contentOffset的值，如果他的纵坐标到某个点以上我们就执行刷新数据，移动到某个点以下我们就执行加载数据。具体看代码可能更好理解。\n\n\t- (void)scrollViewDidScroll:(UIScrollView *)scrollView \n\t{\n    if ([scrollView isEqual:_tableView]) {\n        if (scrollView.contentOffset.y < -50 ) {\n        //下拉刷新方法\n        }\n        if (scrollView.contentOffset.y > 800 ) {\n        //上拉加载方法\n        }\n      }\n    }\n    \n原理很简单，但是实现的话还是有很多细节需要考虑的，比如`scrollView.contentOffset.y < -50`的情况是很多的，当用户快速上拉到-100时，可能在-51执行一次刷新方法，在-52执行一次，-53执行一次。。。。。。这肯定是不合理的。\n\n所以我们需要节流。这里提两个我的个人观点，一个是开线程执行刷新办法，如果线程存在不会新开一个，这样可以保证刷新方法执行一次。还有一种是用KVO监听用户手指松开的动作，松开的时候再刷新，或者` - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate`用这个代理方法，他会帮你监听手指是否松开。这两个方法我都没试过，大家可以自己尝试下，有错希望反馈给我，共同进步。\n\n但是如果仅仅是判定松开我觉得是满足不了需求的。我现在希望就是当用户快下滑到底部时就自动加载新数据，那我应该怎么实现呢？总不能用户一拉到底不松手就不加载吧。\n\n# RAC一个方法实现刷新\n\n我想到了RAC。这个想法可能有点非主流，所以肯定有逻辑考虑不周的地方，希望各位指出。这里我先宏定义了下，为了缩短代码\n\n\t#define VIEWHEIGHT self.view.frame.size.height\n\n然后就是RAC了。\n\n    [[[RACObserve(self.tableView, contentOffset) map:^id(id value) {\n        if (self.tableView.contentOffset.y < -50) {\n            return @\"1\";\n        }\n        if (self.tableView.contentOffset.y > self.tableView.contentSize.height - VIEWHEIGHT * 1.5 && self.tableView.contentSize.height - VIEWHEIGHT * 1.5 > 0) {\n            return @\"2\";\n        }else{\n            return @\"0\";\n        }\n    }] distinctUntilChanged] subscribeNext:^(id x) {\n        debugLog(@\"%@\", x);\n        if ([x integerValue] == 1) {\n            [self netWork];\n        }else if ([x integerValue] == 2){\n            [self loadMoreData];\n        }\n    }];\n    \n这里是用了RAC KVO的写法，不会的可以点[我文章](http://cbsfly.github.io/ios/rac1/)复习下。首先写了一个通知监听tableView的contentOffset，如果发生变化立刻进入map产生的映射中执行map中的方法。我给情况分了类，如果用户下拉，返回1，如果上拉快到底部时返回2。并且在映射完成后用了`distinctUntilChanged`属性，当我的映射值不产生变化时是不会传递映射值的。这样当用户拉倒需要刷新的位置，只会发一个信号给订阅者，只会执行一次刷新数据的方法，这样我所有的需求就迎刃而解了。\n\n如果有更好的办法希望大家给我指出，谢谢大家。","categories":["iOS"]},{"title":"Git问题Everything up-to-date解决","url":"/2021/03/05/2016-01-20-git-date/","content":"\n今天push代码的时候遇到了一个小问题，提示『Everything up-to-date』\n，导致不能push代码，说这里解决了记下小记。\n<!--more-->\n\n# 提交代码遇到『Everything up-to-date』\n\n上网查了下，发现中文大多答非所问，少数能解决的并没有阐述原理，所以我写这篇文章记录下。\n\n这里先上[stackoverflow](http://stackoverflow.com/questions/2936652/git-push-wont-do-anything-everything-up-to-date)的回答，基础好的可以看这个。\n\n接下来说我自己的理解，出现这个问题的原因是git提交改动到缓存，要push的时候不会将本地所有的分支都push掉，所以出现这个问题。我们应该告诉git提交哪个分支。\n\n这里有种特殊的情况是如果你是fork别人的仓库再clone到本地的话，即使git上只有一个主分支，他还是可能出现这个错误。那么我们就需要新建分支提交改动然后合并分支。\n\n接下来先创建一个新分支提交改动\n\n\t$ git branch newbranch\n\t\n然后输入这条命令检查是否创建成功\n\n\t$ git branch\n\t\n这时终端输出\n\n\t  newbranch\n\t* master\n\t\n这样就创建成功了，前面的*代表的是当前你所在的工作分支。我们接下来就要切换工作分支。\n\n\t$ git checkout newbranch\n\t\n这样就切换完了，可以`$ git branch`确认下。然后你要将你的改动提交到新的分支上。\n\n\t$ git add .\n\t$ git commit -a\n\t\n此时可以`$ git status`检查下提交情况。如果提交成功，我们接下来就要回主分支了，代码和之前一样。\n\n\t$ git checkout master\n\t\n然后我们要将新分支提交的改动合并到主分支上\n\n\t$ git merge newbranch\n\t\n合并分支可能产生冲突这是正常的，虽然我们这是新建的分支不会产生冲突，但还是在这里记录下。下面的代码可以查看产生冲突的文件，然后做对应的修改再提交一次就可以了。\n\n\t$ git diff\n\t\n我们的问题就解决了，接下来就可以push代码了。\n\n\t$ git push -u origin master\n\t\n新建分支的朋友别忘了删除这个分支\n\n\t$ git branch -D newbranch\n\t\n如果想保留分支只是想删除已经合并的部分只要把大写的D改成小写的d就行了。\n\n# 参考资料\n\n[分支与合并@基础](http://gitbook.liuhui998.com/3_3.html)","categories":["Git"]},{"title":"摆脱第三方库系列（二）- 自己写一个滚动广告","url":"/2021/03/05/2016-02-24-rollview/","content":"\n# 前言\n\n摆脱第三方库系列第二章，我将介绍滚动广告的写法。在一些信息聚合类APP中滚动广告非常常见或者说必不可少，他可以不需要用户操作展示一些开发者想展示的东西，原理其实也很简单。我写的滚动广告主要实现自动滚动和循环滚动这两个功能，至于广告的点击事件或者美化这都是后话了。\n<!--more-->\n\n# 滚动广告基本原理\n\n其实只要是滚动的东西都离不开UISCrollView，滚动广告的原理就是在一个横向的UISCrollView上放置多张图片并插入文字，然后设置时间自动翻页，点击事件可以通过设置代理方法完成。\n\n而循环播放的原理是这样的，假使我们有五张广告图需要播放，那么我们在UISCrollView应该插入七张图片，除开头尾两张后中间剩下的五张按顺序放置我们要展示的广告，那么头尾两部分放什么呢？\n\n>头部分应该放最后一张也就是第五张广告图，尾部分应该放第一张广告图\n\n这样当用户看到第一张广告图并向左移动时就会出现第五张广告图，然后我们应该在代码中使用一些“小手段”，当广告页滚动到头页的时候应该自动跳到倒数第二页也就是第五张广告页。这样就完成了一个看起来可以循环的轮播广告了。\n\n# 代码实现\n\n先上完成效果图\n\n![wait](https://github.com/cbsfly/cbsfly.github.io/raw/master/images/posts/iOS/rollpage.gif)\n\n接下来上代码，先创建一个继承于UIView的子类RollView，这里不推荐直接继承于UISCrollView，那样可能会因为控件层次问题出现有些控件被覆盖了。\n\n## 接口部分\n\nRollView接口部分如下\n\n\t@interface RollView : UIView<UIScrollViewDelegate>\n\t@property (nonatomic, strong) UIScrollView *rollScrollView;\n\t@property (nonatomic, strong) NSMutableArray *imageArray;\n\t@property (nonatomic, strong) UIImageView *rollImgView;\n\t@property (nonatomic, strong) UIPageControl *pageControl;\n\t@property (nonatomic, strong) NSTimer *timer;\n\t@end\n\nUIPageControl是一个苹果公司给的页面小点的控件，也是滚动广告比较常见的需要添加的控件。而`imageArray`主要是为了存储多个广告图，可以自己封装一个UIImageView这样就可以让自己的广告更加个性了。\n\n为了简化代码先宏定义下\n\n\t#define COUNT self.imageArray.count\n\t#define SVIEWWIDTH self.frame.size.width\n\t#define SVIEWHEIGHT self.frame.size.height\n\t\n## RollView初始化\n\n先看自身的初始化方法，很简单，`addNSTimer`方法是添加一个定时器滚动，一会再介绍。\n\n\t- (instancetype)initWithFrame:(CGRect)frame\n\t{\n\t    self = [super initWithFrame:frame];\n\t    if(self){\n\t        [self addSubview:self.rollScrollView];\n\t        [self addSubview:self.pageControl];\n\t        [self addNSTimer];\n\t    }\n\t    return self;\n\t}\n\n## 各个控件get方法\n\n接下来看get方法\n\n\t- (UIScrollView *)rollScrollView\n\t{\n\t    if (_rollScrollView == nil) {\n\t        _rollScrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, SVIEWWIDTH, SVIEWHEIGHT)];\n\t        _rollScrollView.delegate = self;\n\t        _rollScrollView.contentSize = CGSizeMake((COUNT + 2) * SVIEWWIDTH, SVIEWHEIGHT);\n\t        //使子视图imageview自动适配scrollview的大小\n\t        [_rollScrollView setAutoresizesSubviews:YES];\n\t        //将scrollview设成分页形式\n\t        [_rollScrollView setPagingEnabled:YES];\n\t        //隐藏scrollview两边的滚动条\n\t        [_rollScrollView setShowsVerticalScrollIndicator:NO];\n\t        [_rollScrollView setShowsHorizontalScrollIndicator:NO];\n\t        //设置scrollview初始的位置为第二部分来显示第一张广告\n\t        _rollScrollView.contentOffset = CGPointMake(SVIEWWIDTH, 0);\n\t    }\n\t    return _rollScrollView;\n\t}\n\t\n什么是UISCrollView的contentSize我在[这篇文章](http://cbsfly.github.io/ios/rac-refresh)讲过。由于要循环播放所以要加两张图片，所以宽度为`(COUNT + 2) * SVIEWWIDTH`，其他解释写在注释里了。\n\n然后是pageControl的get方法。\n\n\t- (UIPageControl *)pageControl\n\t{\n\t    if (_pageControl == nil) {\n\t        _pageControl = [[UIPageControl alloc] initWithFrame:CGRectMake((SVIEWWIDTH - _pageControl.bounds.size.width)/2, SVIEWHEIGHT - 10, _pageControl.bounds.size.width, _pageControl.bounds.size.height)];\n\t        _pageControl.currentPageIndicatorTintColor = [UIColor whiteColor];\n\t        _pageControl.pageIndicatorTintColor = [UIColor grayColor];\n\t        [_pageControl setNumberOfPages:COUNT];\n\t    }\n\t    return _pageControl;\n\t}\n\t\n其中`currentPageIndicatorTintColor`是点移动到当前点时的颜色，`pageIndicatorTintColor`是没移动到的点的颜色。\n\n然后在`imageArray`中添加我们的广告图片，由于NSArray是可以存储任何对象类型的，所以我们可以存储广告图也可以直接存UIImageView，这里我是存了任意的五张UIImage，就不上代码了，直接看`rollImgView`。\n\n\t- (UIImageView *)rollImgView\n\t{\n\t    if (_rollImgView == nil) {\n\t        //第一个放最后一个图片\n\t        _rollImgView = [[UIImageView alloc] init];\n\t        _rollImgView.frame = CGRectMake(0, 0, SVIEWWIDTH, SVIEWHEIGHT);\n\t        [_rollImgView setImage:[_imageArray objectAtIndex:(COUNT - 1)]];\n\t        [self.rollScrollView addSubview:_rollImgView];\n\t        //最后一个放第一张图片\n\t        _rollImgView = [[UIImageView alloc] init];\n\t        _rollImgView.frame = CGRectMake(SVIEWWIDTH * (COUNT + 1), 0, SVIEWWIDTH, SVIEWHEIGHT);\n\t        [_rollImgView setImage:[_imageArray objectAtIndex:0]];\n\t        [self.rollScrollView addSubview:_rollImgView];\n        \n\t        for (int i = 0; i < COUNT; i++) {\n\t            _rollImgView = [[UIImageView alloc] init];\n\t            _rollImgView.frame = CGRectMake(SVIEWWIDTH * (i + 1), 0, SVIEWWIDTH, SVIEWHEIGHT);\n\t            [_rollImgView setImage:[_imageArray objectAtIndex:i]];\n\t            [self.rollScrollView addSubview:_rollImgView];\n\t        }\n\t    }\n\t    return _rollImgView;\n\t}\n\t\n这里需要注意的就是每个图片需要放置的frame，想不明白的自己动手画个草稿就一目了然了。我是设置了五张广告图片所以我们应该用七张UIImageView，所以要初始化七次添加七次，可能有点不合理，有更好的办法希望留言告诉我。\n\n## scrollView代理部分\n\n\t- (void)scrollViewDidScroll:(UIScrollView *)scrollView\n\t{\n\t    if (scrollView.contentOffset.x == 0) {\n\t        self.rollScrollView.contentOffset = CGPointMake(COUNT * SVIEWWIDTH, 0);\n\t        self.pageControl.currentPage = (COUNT - 1);\n\t    }else if (scrollView.contentOffset.x == (COUNT + 1) * SVIEWWIDTH){\n\t        self.rollScrollView.contentOffset = CGPointMake(SVIEWWIDTH, 0);\n\t        self.pageControl.currentPage = 0;\n\t    }else{\n\t        int pagenum = (round(scrollView.contentOffset.x/self.rollImgView.frame.size.width) - 1);\n\t        [self.pageControl setCurrentPage:pagenum];\n\t    }\n\t}\n\n\t- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView\n\t{\n\t    [self removeNSTimer];\n\t}\n\t\n\t- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\n\t{\n\t    [self addNSTimer];\n\t}\n\t\n主要代码都在`scrollViewDidScroll`方法中，就是在scrollview滚动时调用的方法。这里主要就是前面提到的实现循环滚动的“小手段”了。\n\n当`scrollView.contentOffset.x == 0`时，说明的此时显示的是头imageview即第五张广告，那么我们需要跳动到第五张广告也就是第六张imageview来完成循环效果，同时也别忘记改版pageControl的当前点。由于是5个点，那么下标是0-4，所以是标到`(COUNT - 1)`处。\n\n`scrollView.contentOffset.x == (COUNT + 1) * SVIEWWIDTH`表示的是在尾imageview时的操作。\n\n如果既不在头也不在尾，我们只需要在滚动时改变标签点就可以了。其中`round`是表示取四舍五入的整数，这样改变标签点更合理。\n\n下面两个方法是说我们鼠标按住scrollview时我们应该取消计时器不再计时，松开手时再开始计时。\n\n## 计时器\n\n\t- (void)addNSTimer\n\t{\n\t    if (self.timer == nil) {\n\t        NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:4 target:self selector:@selector(nextPage) userInfo:nil repeats:YES];\n\t        [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSRunLoopCommonModes];\n\t        self.timer = timer;\n\t    }\n\t}\n\n\t- (void)removeNSTimer\n\t{\n\t    [self.timer invalidate];\n\t    self.timer =nil;\n\t}\n\n\t- (void)nextPage\n\t{\n\t    if (self.rollScrollView.contentOffset.x == ((COUNT) * self.rollImgView.frame.size.width)) {\n\t        [self.rollScrollView scrollRectToVisible:CGRectMake(SVIEWWIDTH, 0, SVIEWWIDTH, SVIEWHEIGHT) animated:YES];\n\t    }else{\n\t        [self.rollScrollView scrollRectToVisible:CGRectMake(self.rollScrollView.contentOffset.x + self.rollImgView.frame.size.width, 0, SVIEWWIDTH, SVIEWHEIGHT) animated:YES];\n\t    }\n\t}\n\t\n这里主要是三个自定义方法，顾名思义都比较简单，这里不做详细介绍了。\n\n接下来就将RollView添加到ViewController中就可以展示了。\n\n# 总结\n\n这样滚动广告差不多就介绍完了，我只是介绍了基本原理，在我们的开发中肯定是不能完全满足需求的，所以还要加一些自定义的更改。比如用自定义的imageview并用代理方法增加点击事件，或者直接不用imageview用buttun。demo我也会放到我的[github](https://github.com/cbsfly/cbsRollView)上。\n\n还是那句话，如果有错还请指出，万分感谢。\n\n# 相关文章\n\n[摆脱第三方库系列（一）-自己写一个侧拉菜单](http://cbsfly.github.io/ios/slipview)","categories":["iOS"]},{"title":"探究RAC-RAC信号处理方法归纳","url":"/2021/03/05/2016-01-06-rac2/","content":"*继续完成RAC的坑*\n\n<hr />\n\n# 前言\n\n经过[上篇文章](http://cbsfly.github.io/ios/rac1/)的学习，相信不少读者已经熟悉了RAC的基本用法，可以尝试在以后的开发中不用`add target`语句了。这篇文章将稍微深入一点了解RAC的更多功能以及适用场合。\n<!--more-->\n\n# 什么是信号\n\nRAC的核心就是信号，即`RACSignal`。\n\n>信号可以看做是传递信号的工具，当数据变化时，信号就会发送改变的信息，以通知信号的订阅者执行方法。\n\n## 热/冷信号\n\n>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。\n\n## 自己动手写一个RACSignal\n\n\t//创建信号\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [subscriber sendNext:@\"signal\"];\n        [subscriber sendCompleted];\n        return nil;\n    }];\n    \n    //订阅信号\n    [signal subscribeNext:^(id x) {\n        NSLog(@\"x = %@\", x);\n    } error:^(NSError *error) {\n        NSLog(@\"error = %@\", error);\n    } completed:^{\n        NSLog(@\"completed\");\n    }];\n    \n这是一个信号从创建到接收的完整过程，我们接下来看看控制台输出了什么。\n\n\t2016-01-05 14:33:06.106 RACStudyTest[895:38671] x = signal\n\t2016-01-05 14:33:06.106 RACStudyTest[895:38671] completed\n\n可以看到，创建信号时我们sent了一个signal，在我们订阅`subscribeNext`时存储在x中的就是这个字符串signal。从这里看出来，不但我们可以给订阅者传递字符串，只要是一个类一个对象我们都可以传递。\n\n另一方面控制台输出了completed说明订阅信号部分的completed块下得方法也被执行了，这是因为饿哦在创建时发送完signal后又发送了一个completed。同理，error下得方法我们也可以这样调用。\n\n融汇贯通一下，我们之前学的所有RAC的用法就是一个创建信号订阅信号的过程！\n\n# 信号的处理\n\n## map\n\n这里的map不是地图，而是映射的意思，就是创建一个订阅者的映射并且返回数据，具体用法我们来看代码。\n\n    [[self.textFild.rac_textSignal map:^id(id value) {\n        NSLog(@\"%@\", value);\n        return @1;\n    }] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n\n在TextFild控件中输入good，输出：\n\n\t2016-01-05 15:02:15.180 RACStudyTest[1418:57245] 1\n\t2016-01-05 15:02:21.710 RACStudyTest[1418:57245] g\n\t2016-01-05 15:02:21.711 RACStudyTest[1418:57245] 1\n\t2016-01-05 15:02:22.954 RACStudyTest[1418:57245] go\n\t2016-01-05 15:02:22.955 RACStudyTest[1418:57245] 1\n\t2016-01-05 15:02:23.464 RACStudyTest[1418:57245] goo\n\t2016-01-05 15:02:23.464 RACStudyTest[1418:57245] 1\n\t2016-01-05 15:02:23.705 RACStudyTest[1418:57245] good\n\t2016-01-05 15:02:23.705 RACStudyTest[1418:57245] 1  \n\n还是之前那个监听textfild编辑变化的例子，可以看到，当信号被订阅变成热信号后，这里的map构造的映射块value的值就是控件中的字符变化，而订阅者x的值就是映射者的返回值1。\n\n根据这个功能我们就可以对我们监测的东西和我们需求的东西进行转换。比如监听了字符串变化，我们需要的时变化后的字符串长度而不是变化的字符串本身，则可以在map的返回值中返回`text.length`，就可以实时捕获到字符串长度；甚至做一个映射表，将各个变化进行一对一或者一对多或者多对一的处理。\n\n## filter\n\nfilter就是过滤，它可以帮助你筛选出你需要的信号变化。\n\n    [[self.textFild.rac_textSignal filter:^BOOL(NSString *value) {\n        return [value length] > 3;\n    }] subscribeNext:^(id x) {\n        NSLog(@\"x = %@\", x);\n    }];\n\n输入goodnight，输出：\n\n\t2016-01-05 15:18:20.492 RACStudyTest[1490:66721] x = good\n\t2016-01-05 15:18:27.917 RACStudyTest[1490:66721] x = goodn\n\t2016-01-05 15:18:28.129 RACStudyTest[1490:66721] x = goodni\n\t2016-01-05 15:18:28.433 RACStudyTest[1490:66721] x = goodnig\n\t2016-01-05 15:18:28.930 RACStudyTest[1490:66721] x = goodnigh\n\t2016-01-05 15:18:29.155 RACStudyTest[1490:66721] x = goodnight\n\t\n上述例子是在字符串长度大于3时才会输出变换后的字符串。\n\n## take/skip/repeat\n\ntake是获取，skip是跳过，这两个方法后面跟着的都是NSInteger。所以`take 2`就是获取前两个信号，`skip 2`就是跳过前两个。repeat是重复发送信号。\n\n    RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [subscriber sendNext:@\"1\"];\n        [subscriber sendNext:@\"2\"];\n        [subscriber sendNext:@\"3\"];\n        [subscriber sendNext:@\"4\"];\n        [subscriber sendNext:@\"5\"];\n        [subscriber sendCompleted];\n        return nil;\n    }] take:2];\n    \n    [signal subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }completed:^{\n        NSLog(@\"completed\");\n    }];\n    \n这个demo只会输出前两个信号1和2还有完成信号completed，skip,repeat同理。\n\n相似的还有`takeLast` `takeUntil` `takeWhileBlock` `skipWhileBlock` `skipUntilBlock` `repeatWhileBlock`都可以根据字面意思来理解。\n\n\n## delay\n\n延时信号，顾名思义，即延迟发送信号。\n\n    RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [subscriber sendNext:@\"delay\"];\n        [subscriber sendCompleted];\n        return nil;\n    }] delay:2];\n    \n    NSLog(@\"tag\");\n    \n    [signal subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n    \n输出：\n\n\t2016-01-05 15:27:55.908 RACStudyTest[1543:71256] tag\n\t2016-01-05 15:27:58.102 RACStudyTest[1543:71256] delay\n\t\n看时间可以发现订阅者延迟了2秒才收到信号打印出x的值。*PS：还有0.2s误差是因为运行到不同代码行的时间差*\n\n## throttle\n\n节流，在我们做搜索框的时候，有时候需求的时实时搜索，即用户每每输入字符，view都要求展现搜索结果。这时如果用户搜索的字符串较长，那么由于网络请求的延时可能造成UI显示错误，并且多次不必要的请求还会加大服务器的压力，这显然是不合理的，此时我们就需要用到节流。\n\n    [[[self.textFild rac_textSignal] throttle:0.5] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n\n加了节流管道，后面跟上了类型为NSTimeInterval的参数后，只有0.5S内信号不产生变化才会发送请求，这样快速的输入也不会造成多次输出。\n\n## distinctUntilChanged\n\n网络请求中为了减轻服务器压力，无用的请求我们应该尽可能不发送。`distinctUntilChanged`的作用是使RAC不会连续发送两次相同的信号，这样就解决了这个问题。\n\n    [[[self.textFild rac_textSignal] distinctUntilChanged] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];   \n\n## timeout\n\n超时信号，当超出限定时间后会给订阅者发送error信号。\n\n    RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{\n            [subscriber sendNext:@\"delay\"];\n            [subscriber sendCompleted];\n        }];\n        return nil;\n    }] timeout:2 onScheduler:[RACScheduler mainThreadScheduler]];\n    \n    [signal subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    } error:^(NSError *error) {\n        NSLog(@\"%@\", error);\n    }];\n    \n输出：\n\n\t2016-01-05 15:41:58.686 RACStudyTest[1604:76716] Error Domain=RACSignalErrorDomain Code=1 \"The operation couldn’t be completed. (RACSignalErrorDomain error 1.)\"\n\t\n由于在创建信号是限定了延迟3秒发送，但是加了timeout2秒的限定，所以这一定是一个超时信号。这个信号被订阅后，由于超时，不会执行订阅成功的输出x方法，而是跳到error的块输出了错误信息。timeout在用RAC封装网络请求时可以节省不少的代码量。\n\n## ignore\n\n忽略信号，指定一个任意类型的量（可以是字符串，数组等），当需要发送信号时讲进行判断，若相同则该信号会被忽略发送。\n\n    [[[self.textFild rac_textSignal] ignore:@\"good\"] subscribeNext:^(id x) {\n        NSLog(@\"%@\", x);\n    }];\n    \n# 总结\n\n这篇文章比上一篇稍稍深入了RAC的附加功能，但还有很多例如扁平映射`flattenMap`，Signal of Signals都没有提到，RAC的东西实在太多太多，我说的也仅仅是九牛一毛。我将继续研究RAC的深入用法，并发文给大家介绍。如果文中有什么错误，也希望大家给我指出来，我将万分感谢。","categories":["iOS"]},{"title":"浅谈Objectiv-C中的Block","url":"/2021/03/05/2016-01-10-block/","content":"# 前言\n\n由于“业务”需求，最近我准备复习下Objective-C中的“块”，也就是大家并不陌生的block，顺便做点小笔记。说实话，其实自己之前对block不是很熟悉，所以这篇文章主要是基础知识，不会涉及太多深层次的东西，个人认为给自己也就是刚接触iOS开发的新手看看还是有作用的。\n<!--more-->\n\n# 理解Block\n\n在《Learning Cocoa with Objective-C》这本书中说我们可以把block看作是一个变量（variables），但这个变量和一般的变量有一点不同，它不像别的变量可能存储一个整型数或者字符串，它存储的是一段代码。我觉得这个理解很不错，以后我们遇到了block，不妨**将block看作一个变量**。\n\n# 如何看懂一个block？\n\n要读懂，我们首先要会写block。block的声明大致可以分为下面五种形式。\n\n## 1.block作为局部变量\n\n\treturnType (^blockName)(parameterTypes) = ^returnType(parameters) {code};\n\n这种形式可以看作最基本的block声明形式，最好动手在自己的Xcode中敲一敲。\n\n## 2.block作为接口部分属性指令\n\n\t@property (nonatomic, copy) returnType (^blockName)(parameterTypes);\n\n## 3.block作为某个方法的形式参数\n\n\t-(void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName;\n\n## 4.block作为一个被调用的方法\n\n\t[someObject someMethodThatTakesABlock:^returnType (parameters) {code}];\n\n## 5.宏定义\n\n\ttypedef returnType (^TypeName)(parameterTypes);\n\tTypeName blockName = ^returnType(parameters) {...};\n\n看完后相信读者和笔者都有一个感觉就是OC中得block非常反人类。但是我们还是可以做一些总结，比如任何情况下block的返回类型都不会单独在一对括号里；block所需要的形参都是单独在括号中的且括号之前没有^符号。^符号可以说是block的标志，凡是看到^符号就可以认为这是一个block，且括号内的一般式参数类型或者参数名，极少数情况会是block的名字（一般很少情况下会必须给block起名字，所以很多block是没有名字的）。至于block的调用方法是与函数的调用方法一致的。\n\n这么复杂的定义为何我们还要去学呢？因为block的作用其实非强大。block可以说是OC中**实现函数式编程的基础**。当我们写一个动画的过程时需要使用block；当我们需要回调网络请求的时候需要block；当我们需要更新UI的时候我们需要block。\n\n# block是如何运行的？\n\n我们先来看一个简单的demo。\n\n\t//声明一个block \n    void (^block)() = ^void (){\t //Step.1\n        NSLog(@\"1\");\t//Step.3\n    };\n    //调用block \n    block();\t\t//Step.2\n\n输出很简单就是一个1.为什么要举这个demo呢？我们不妨打个断点来看看。令人惊奇的是，在遇到block的时候我们的代码不是从上往下运行了，当执行到Step.1时函数不再往下执行NSLog方法而是到了Step.2，而Step.2调用了block函数此时才执行块中得NSLog也就是Step.3。\n\n所以上文就说了，我们应该把block看作是一个变量。当我们定义了一个`int x`的时候编译程序不会在乎你x的值是什么，而当你要用x做输出或者加减法的时候编译程序才会在内存空间中取出x进行运算。block也是这个道理。\n\n但我们也不能把Block简单的当做是一个变量，我们来看下一个demo；\n\n    int x = 10;\n    \n    void (^block)() = ^void (){\n        NSLog(@\"%d\", x);\n    };\n    \n    block();\n    x = 11;\n    block();\n\n结果两个调用block输出都是10。这就是我们常说的[闭包](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))。\n\n>\n在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的 函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。\n\n可以认为，在调用block内部函数时，里面的变量值就是block创建时变量的值。block可以看作是一个封闭的块，一个“不受外界干扰”的块。\n\n**在我们的实际开发中，我们就是要利用block的回调特性和闭包特性。**\n\n# block的应用\n\n## 1.网络请求\n\n在网络请求中，block主要是处理网络请求的返回值。一个网络请求不仅有返回数据的情况，也有超时或者链接错误等失败情况，这时我们就需要block。\n\n    [SomeClass getURL:someURL finished:^(NSData * data,NSURLResponse *response,NSError *error) {\n            if (error) {\n            ...\n        }else{\n            if (success) {\n                ...\n            }\n        }\n\t}];\n\n为什么这里要用block呢？这里偷懒引用下美团的原文。（其实是怕我自己的理解有误）\n\n>这里网络请求是异步的，所以当block中代码执行时，getURL:finished:方法调用所在的栈很可能已经不存在了，但是因为回调block和someURL构成了closure，所以即使栈不存在，block仍然可以引用到someURL。\n\n>可能你会说，“我在block中增加一个NSURL类型的参数，把someURL传回来不也可以实现同样的目的吗？”不妨设想如果我们在block中要引用的对象有10个之多，用参数列表传递明显不再现实，用容器类或者专门定义一个类来传递虽然可以，但是前者没有编译器为我们检查错误，后者则相当繁琐。而利用闭包，可以轻易达到灵活性和简洁性的平衡。事实上，美团客户端就大量利用了闭包，在UI层发出请求，在回调中更新某些UI组件。\n\n而再获取了数据之后，我们还可以直接在块中进行操作，例如更新UI，例如存储model，甚至错误的弹框。\n\n## 2.动画\n\n    UIView *ppview = [[UIView alloc] initWithFrame:CGRectMake(0, SCREENHEIGHT/2-50, 50, 50)];\n    ppview.backgroundColor = [UIColor yellowColor];\n    [self.view addSubview:ppview];\n    [UIView animateWithDuration:1.0f animations:^{\n        ppview.frame = CGRectMake(SCREENWIDTH, SCREENHEIGHT/2-50, 50, 50);\n    } completion:^(BOOL finished) {\n        ppview.frame = CGRectMake(SCREENWIDTH/2-25, SCREENHEIGHT/2-50, 50, 50);\n    }];\n    \n这里为了使代码看起来简洁用了宏定义，所以代码前要加两句话\n\n\t#define SCREENWIDTH [UIScreen mainScreen].bounds.size.width\n\t#define SCREENHEIGHT [UIScreen mainScreen].bounds.size.height\n\t\n动画的具体效果大家可以自己看，这不是重点。动画部分主要利用了块可以存储代码这一特性，使得动画的代码更简洁易懂。试想若不用block，先不管能不能实现动画效果，每个动画添加一个方法，可能一个简单的动画将有大量的代码。\n\n# 总结\n\n写这篇文章深深感受到自己的基础知识的不够用，其实自己写文的初衷也是想自己踏踏实实的学习iOS开发，写文对知识的总结还是很有效果的。\n\n由于理解不到位，block的应用那一节可能说的不是很好，希望有错的部分大家一定要帮我指出来，我一定虚心接受。\n\n# 参考文章\n\n[How Do I Declare A Block in Objective-C?](http://fuckingblocksyntax.com/)\n\n[block在美团iOS的实践](http://tech.meituan.com/block-in-Meituan-iOS.html)","categories":["iOS"]},{"title":"学习RAC小记-适合给新手看的RAC用法总结","url":"/2021/03/05/2016-01-03-rac1/","content":"*最近叶大直播写代码，我也做点小笔记。*\n\n<hr />\n\n# 什么是RAC？\n\n几乎每一篇介绍RAC的文章开头都是这么一个问题。我这篇文章是写给新手（包括我自己）看的，所以这个问题更是无法忽视。\n\n简单的说，RAC就是一个第三方库，他可以大大简化你的代码过程。\n\n官方的说，[ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)（其简称为RAC）是由GitHub开源的一个应用于iOS和OS X开发的新框架。RAC具有[函数式编程](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)和[响应式编程](https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B)的特性。\n<!--more-->\n\n# 为什么我们要学习RAC？\n\n为了提高我们的开发效率。RAC在某些特定情况下开发时可以大大简化代码，并且目前来看安全可靠。\n\n# 配置RAC环境\n\n我习惯用cocoapods来安装github上得开源库，不会的新手iOS开发者有兴趣可以去学一下。\n\n想学习cocoapods的同学推荐[唐巧前辈的文章](http://devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/)。\n\n\tplatform:ios, '8.0'\n\tpod 'ReactiveCocoa','~>2.1.8'\n\n这里有一点要注意下就是RAC的版本问题，由于还没学习Swift，所以我是用OC编写程序的，最新版的RAC已经支持Swift了，但是在OC的程序安装最新版的RAC可能跑不起来，所以推荐大家使用2.5.0版本以下的RAC（具体支持Swift的版本可能有误，但我引用的2.1.8肯定是没问题的）。\n\n# 使用RAC\n\n## 1.target-action\n\nRAC最基本的入门使用技巧就是对事件的监听。\n\n*PS:在iOS开发中，我们所说的点击事件其实就是target-action，接触过iOS开发的人都不会陌生UIControlEventTouchUpInside，这就是按下并松开的动作。不仅仅是UIButton，还有UITextField也有目标-动作模式。*\n\n使用前别忘了引用头文件~\n\n\t#import <ReactiveCocoa/ReactiveCocoa.h>\n\n接下来就是最关键的RAC代码了。\n\n\t[[self.textFild rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(id x){\n        NSLog(@\"change\");\n    }];\n    \n就这么短短的两行代码。他实现了一个功能，即监听了textFild的UIControlEventEditingChanged事件，当事件发生时实现方法`NSLog`。\n所以我们就可以以这段代码为模板进行RAC的使用，举一反三，以后的UIButton点击事件我们都可以用RAC方法进行添加，再也不用`add Target`了。\n对于textFild的文字更改监听也有更简单的写法\n\n    [[self.textFild rac_textSignal] subscribeNext:^(id x) {\n        NSLog(@\"%@\",x);\n    }];\n    \n这样就是每次改变TextFild都输出改变后的结果。\n\n再比如给我们的某个label添加一个手势动作，我们也可以用简单的RAC代码完成\n\n\tUITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];\n\t[[tap rac_gestureSignal] subscribeNext:^(id x) {\n        NSLog(@\"tap\");\n    }];\n    [self.view addGestureRecognizer:tap];\n    \n这段具体我就不解释了，相信大家都能看得懂，看不懂的自己写写就懂了。\n    \n## 2.代理\n\n*用RAC写代理是有局限的，它只能实现返回值为void的代理方法*\n\n首先我们要明白我们为什么要用RAC写代理？答：简化代码！是的，的确为了简化代码，为什么我要再这里强调这个，是因为在代理方法中我深深的感受到了RAC的优点。一开始我也不愿意花功夫去学RAC，但是我师父给我举了一个例子，如果一个View里有多个AlertView，每个AlertView有很多个按钮，每个按钮都有自己的点击事件，我应该怎么写？我想了一下，不但每个按钮需要打标记，而且每个AlertView也要打标记，然后再往代理点击事件里加各种方法，代码就又臭又长。那么让我们看看RAC怎么写代理方法。\n\n    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"RAC\" message:@\"RAC TEST\" delegate:self cancelButtonTitle:@\"cancel\" otherButtonTitles:@\"other\", nil];\n    [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple *tuple) {\n        NSLog(@\"%@\",tuple.first);\n        NSLog(@\"%@\",tuple.second);\n        NSLog(@\"%@\",tuple.third);\n    }];\n    [alertView show];\n    \n我们来看RAC的语句。`@selector`是指这次事件监听的方法`fromProtocol`指依赖的代理。这里block中有一个RACTuple，他相当于是一个集合类，他下面的first，second等就是类的各个参数，我这里点了AlertView第二个按钮other输出了一下。\n\n\t2016-01-04 18:24:29.114 RACStudyTest[5003:388870] <UIAlertView: 0x7ff260c90c70; frame = (0 0; 0 0); layer = <CALayer: 0x7ff260c91030>>\n\t2016-01-04 18:24:29.115 RACStudyTest[5003:388870] 1\n\t2016-01-04 18:24:29.115 RACStudyTest[5003:388870] (null)\n\t\n可以看出`tuple.second`是ButtonAtIndex中Button的序号。那么对于上面那个我举的例子，就可以用`switch`给各个按钮添加方法，这样的代码看起来更容易理解，方面后期维护。\n\n当然了，AlertView代理也有简化的代码。\n\n    [[alertView rac_buttonClickedSignal] subscribeNext:^(id x) {\n        NSLog(@\"%@\",x);\n    }];\n    \n这里的x就是各个Button的序号了，可以直接应对我上述遇到的问题。\n\n## 3.通知\n\n在我们的开发中通知也是一个比较常用的功能，主要的应用场景是某个页面进行数据重传需要更新model但是点击返回栈时不会刷新返回界面的数据，这时就可以用通知来更新另一个页面的数据，当然我们也可以在另一个页面的`ViewDidAppear`方法中刷新数据，但那是题外话。\n\n这里写的Demo就是我上述说的情况。\n\n首先，在某个页面中我们需要发出通知，这里就是最基本的通知的写法。发送名为postdata的通知并传送一个数组dataArray。\n\n    NSMutableArray *dataArray = [[NSMutableArray alloc] initWithObjects:@\"1\", @\"2\", @\"3\", nil];\n    [[NSNotificationCenter defaultCenter] postNotificationName:@\"postData\" object:dataArray];\n    \n而在接受的页面我们需要增加观察者并接受数组，这时我们的RAC就派上用场了。\n\n    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:@\"postData\" object:nil] subscribeNext:^(NSNotification *notification) {\n        NSLog(@\"%@\", notification.name);\n        NSLog(@\"%@\", notification.object);\n    }];\n    \n当这个页面监听到名为postdata的通知时他就会执行block中的方法，当然这里的参数改成`id x`也是可以的，这里用NSNotification主要是强调它的类型。让我们看看控制台的输出。\n\n\t2016-01-04 20:10:52.274 RACStudyTest[5918:439077] postData\n\t2016-01-04 20:10:52.275 RACStudyTest[5918:439077] (\n    1,\n    2,\n    3\n\t)\n\n可见，notification.object就是我们想要的数组，当然我们也可以传一些model。值得一提的是，**RAC中的通知不需要`remove observer`，**因为在rac_add方法中他已经写了remove。\n\n## 4.KVO\n\nRAC中得KVO大部分都是宏定义，所以代码异常简洁，简单来说就是`RACObserve(TARGET, KEYPATH)`这种形式，TARGET是监听目标，KEYPATH是要观察的属性值，这里举一个很简单的例子，如果UIScrollView滚动则输出success。\n\n    UIScrollView *scrolView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, 200, 400)];\n    scrolView.contentSize = CGSizeMake(200, 800);\n    scrolView.backgroundColor = [UIColor greenColor];\n    [self.view addSubview:scrolView];\n    [RACObserve(scrolView, contentOffset) subscribeNext:^(id x) {\n        NSLog(@\"success\");\n    }];\n    \n如果你好好回顾下KVO的写法会不会更加感叹RAC的强大呢？\n\n# 总结\n\nRAC的东西很多，但相信这篇文章给大家入门还是可以的，这里介绍了RAC得基本使用方法，但是还有很多好用的东西比如信号都没介绍，甚至除了subscribeNext还有subscribeComplete和subscribeError，这些都是我给自己留得坑，以后也会发文介绍给大家。","categories":["iOS"]}]